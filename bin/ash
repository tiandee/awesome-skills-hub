#!/bin/bash

# ==============================================================================
# ASH (Awesome-Skills-Hub) CLI
# ==============================================================================
# A lightweight package manager for AI IDE skills.
# Author: Tiandee
# Version: 1.0.0
# ==============================================================================

VERSION="1.1.11"

# é¢œè‰²å®šä¹‰
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m'

# Logger Functions (Must be defined before use)
log_info() { echo -e "${BLUE}[ä¿¡æ¯]${NC} $1"; }
log_success() { echo -e "${GREEN}[æˆåŠŸ]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[è­¦å‘Š]${NC} $1"; }
log_error() { echo -e "${RED}[é”™è¯¯]${NC} $1"; }

# åŸºç¡€è·¯å¾„é…ç½®
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ASH_HOME="$HOME/.ash"
SKILLS_DIR="$ASH_HOME/skills"

# Check if global skills exist. If not, initialize them from the package (First Run Logic)
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
# Debug path resolution
# echo "DEBUG: SCRIPT_DIR=$SCRIPT_DIR"
# echo "DEBUG: PROJECT_ROOT=$PROJECT_ROOT"

if [ ! -d "$SKILLS_DIR" ]; then
    LOCAL_SKILLS="$PROJECT_ROOT/skills"
    
    # Check if we can find the skills package
    if [ -d "$LOCAL_SKILLS" ]; then
        log_info "é¦–æ¬¡è¿è¡Œï¼Œæ­£åœ¨åˆå§‹åŒ–å…¨å±€ç¯å¢ƒ (~/.ash)..."
        log_info "ä» $LOCAL_SKILLS å¤åˆ¶æŠ€èƒ½..."
        
        mkdir -p "$ASH_HOME"
        cp -r "$LOCAL_SKILLS" "$SKILLS_DIR"
        
        if [ -d "$SKILLS_DIR" ]; then
            log_success "åˆå§‹åŒ–å®Œæˆï¼"
        else
            log_error "åˆå§‹åŒ–å¤±è´¥ï¼šå¤åˆ¶æ“ä½œæœªèƒ½åˆ›å»ºç›®æ ‡ç›®å½•ã€‚"
        fi
    else
        # Critical Debug Logic: why can't we find the skills?
        # log_warn "DEBUG: æœªåœ¨å®‰è£…åŒ…å†…æ‰¾åˆ° skills ç›®å½•: $LOCAL_SKILLS"
        # ls -F "$PROJECT_ROOT" # Try to see what IS there
        :
    fi
fi

# ç›®æ ‡è·¯å¾„é…ç½® (ä»…æ”¯æŒ Skills çš„å¹³å°)
HOME_DIR="$HOME"
AGENT_SKILLS_DIR="$HOME_DIR/.agent/skills"       # Google Antigravity
CURSOR_SKILLS_DIR="$HOME_DIR/.cursor/skills"     # Cursor
TRAE_SKILLS_DIR="$HOME_DIR/.trae/skills"         # TRAE
WINDSURF_SKILLS_DIR="$HOME_DIR/.windsurf/skills" # Windsurf
COPILOT_SKILLS_DIR="$HOME_DIR/.copilot/skills"   # VS Code + Copilot
CLAUDE_SKILLS_DIR="$HOME_DIR/.claude/skills"     # Claude Code
TRAE_CN_SKILLS_DIR="$HOME_DIR/.trae-cn/skills"   # Trae Chinese Version

# ------------------------------------------------------------------------------
# è¾…åŠ©å‡½æ•°: æå–æŠ€èƒ½æè¿° (æ”¯æŒ YAML å’Œ Markdown)
# ------------------------------------------------------------------------------
extract_description() {
    local file="$1"
    if [ ! -f "$file" ]; then return; fi
    
    # æ£€æŸ¥æ˜¯å¦åŒ…å« YAML å‰ç½®å…ƒæ•°æ®
    if [ "$(head -n 1 "$file" 2>/dev/null)" == "---" ]; then
        # ä» YAML ä¸­æå– description æˆ– name
        local desc=$(sed -n '/^description:/p' "$file" | head -n 1 | sed 's/^description:\s*//' | sed 's/^["\x27]//;s/["\x27]$//')
        if [ -n "$desc" ]; then
            echo "$desc"
            return
        fi
        local name=$(sed -n '/^name:/p' "$file" | head -n 1 | sed 's/^name:\s*//' | sed 's/^["\x27]//;s/["\x27]$//')
        if [ -n "$name" ]; then
            echo "$name"
            return
        fi
    fi
    
    # ä¼ ç»Ÿçš„ Markdown æ ‡é¢˜
    head -n 5 "$file" | grep "^# " | head -n 1 | sed 's/^#\s*//'
}

log_info() { echo -e "${BLUE}[ä¿¡æ¯]${NC} $1"; }
log_success() { echo -e "${GREEN}[æˆåŠŸ]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[è­¦å‘Š]${NC} $1"; }
log_error() { echo -e "${RED}[é”™è¯¯]${NC} $1"; }

show_version() {
    echo -e "${CYAN}ASH (Awesome-Skills-Hub) v${VERSION}${NC}"
    echo "AI IDE æŠ€èƒ½ç®¡ç†å·¥å…·"
}

show_help() {
    show_version
    echo ""
    echo -e "${YELLOW}ç”¨æ³•:${NC} ash <å‘½ä»¤> [å‚æ•°]"
    echo ""
    echo -e "${YELLOW}å‘½ä»¤:${NC}"
    echo "  init              åˆå§‹åŒ–ç¯å¢ƒå¹¶æ£€æµ‹å·²å®‰è£…çš„ IDE"
    echo "  list              åˆ—å‡ºæ‰€æœ‰å¯ç”¨æŠ€èƒ½"
    echo "  info <name>       æŸ¥çœ‹æŠ€èƒ½çš„è¯¦ç»†æè¿°å’Œå†…å®¹é¢„è§ˆ"
    echo "  search <keyword>  æ ¹æ®å…³é”®è¯æœç´¢æŠ€èƒ½"
    echo "  status            æ˜¾ç¤ºå·²å®‰è£…çš„æŠ€èƒ½"
    echo "  install <name>    å®‰è£…æŠ€èƒ½ (åˆ›å»ºè½¯é“¾æ¥åˆ°æ‰€æœ‰å·²æ£€æµ‹çš„ IDE)"
    echo "  uninstall <name>  å¸è½½æŠ€èƒ½ (åˆ é™¤è½¯é“¾æ¥ï¼Œæ”¯æŒ --all å¸è½½å…¨éƒ¨)"
    echo "  clean <ide|--all>     æ¸…ç©ºæŒ‡å®š IDE (æˆ–æ‰€æœ‰) çš„æŠ€èƒ½ç›®å½•"
    echo "  sync              åŒæ­¥æ›´æ–°æŠ€èƒ½ä»“åº“ (git pull)"
    echo ""
    echo -e "${YELLOW}é€‰é¡¹:${NC}"
    echo "  -v, --version     æ˜¾ç¤ºç‰ˆæœ¬ä¿¡æ¯"
    echo "  -h, --help        æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯"
    echo ""
    echo -e "${YELLOW}ç¤ºä¾‹:${NC}"
    echo "  ash init                      # åˆå§‹åŒ–å¹¶æ£€æµ‹ IDE"
    echo "  ash list                      # æŸ¥çœ‹æ‰€æœ‰æŠ€èƒ½åˆ†ç±»"
    echo "  ash info pdf                  # æŸ¥çœ‹ PDF æŠ€èƒ½è¯¦æƒ…"
    echo "  ash search react              # æœç´¢æŠ€èƒ½"
    echo "  ash install java/expert       # å®‰è£…æŠ€èƒ½"
    echo "  ash status                    # æŸ¥çœ‹å·²å®‰è£…æŠ€èƒ½"
    echo "  ash uninstall expert          # å¸è½½æŒ‡å®šæŠ€èƒ½"
    echo "  ash uninstall --all           # å¸è½½æ‰€æœ‰å·²å®‰è£…æŠ€èƒ½"
}

# ------------------------------------------------------------------------------
# è¾…åŠ©å‡½æ•°: æ™ºèƒ½è§£ææŠ€èƒ½è·¯å¾„
# ------------------------------------------------------------------------------
resolve_skill_path() {
    local input="$1"
    
    # 1. å°è¯•ç›´æ¥åŒ¹é…è·¯å¾„
    local direct_path="$SKILLS_DIR/$input"
    
    # Check for Folder Skill (Must contain SKILL.md)
    if [ -d "$direct_path" ] && [ -f "$direct_path/SKILL.md" ]; then
        echo "$direct_path"
        return 0
    fi
    
    # Check for File Skill
    if [ -f "$direct_path" ]; then
        echo "$direct_path"
        return 0
    fi
    if [ -f "${direct_path}.md" ]; then
        echo "${direct_path}.md"
        return 0
    fi
    
    # 2. æœç´¢ï¼šåŒæ—¶æŸ¥æ‰¾ .md æ–‡ä»¶å’Œç›®å½•å‹æŠ€èƒ½
    local matches=()
    
    # æŸ¥æ‰¾ .md æ–‡ä»¶
    while IFS= read -r file; do
        matches+=("$file")
    done < <(find "$SKILLS_DIR" -type f -name "${input}.md")
    
    # æŸ¥æ‰¾åŒåç›®å½• (å¿…é¡»åŒ…å« SKILL.md)
    while IFS= read -r dir; do
        if [ -f "$dir/SKILL.md" ]; then
            matches+=("$dir")
        fi
    done < <(find "$SKILLS_DIR" -type d -name "${input}")

    local count=${#matches[@]}
    
    if [ "$count" -eq 1 ]; then
        echo "${matches[0]}"
        return 0
    elif [ "$count" -gt 1 ]; then
        echo -e "${YELLOW}[è­¦å‘Š]${NC} å‘ç°å¤šä¸ªåŒ¹é…çš„æŠ€èƒ½ï¼Œè¯·å°è¯•ä½¿ç”¨å®Œæ•´è·¯å¾„å®‰è£…:" >&2
        for match in "${matches[@]}"; do
            local rel="${match#$SKILLS_DIR/}"
            echo -e "  - ${CYAN}ash install $rel${NC}" >&2
        done
        return 2 # å†²çª
    fi
    
    return 1 # æœªæ‰¾åˆ°
}

# ------------------------------------------------------------------------------
# è¾…åŠ©å‡½æ•°: è·å–æ‰€æœ‰å¯ç”¨æŠ€èƒ½åˆ—è¡¨ (å»é‡/è¿‡æ»¤)
# Returns: Array of valid skill paths (files or folder paths) printed to stdout
# ------------------------------------------------------------------------------
get_all_skills() {
    while IFS= read -r item; do
        local rel_path="${item#$SKILLS_DIR/}"
        local filename="${rel_path##*/}"

        # 1. Folder Skill (SKILL.md) -> Return parent dir
        if [ "$filename" = "SKILL.md" ]; then
            echo "$(dirname "$item")"
            continue
        fi

        # 2. Ordinary .md File
        if [ "$filename" == "README.md" ]; then continue; fi

        # 2.2 Shadowing Check
        local core_name="${filename%.md}"
        if [ -f "$SKILLS_DIR/$core_name/SKILL.md" ]; then continue; fi
        
        # 2.3 Nested File Check
        local top_level_dir="${rel_path%%/*}"
        if [ -f "$SKILLS_DIR/$top_level_dir/SKILL.md" ]; then continue; fi
        
        echo "$item"
    done < <(find "$SKILLS_DIR" -type f -name "*.md" ! -name "README.md" | sort)
}

# ------------------------------------------------------------------------------
# IDE Detection Logic
# ------------------------------------------------------------------------------
detect_ide() {
    local name="$1"
    local check_dir="$2"
    local check_cmd="$3"
    local init_action="$4"

    local found=0
    if [ -n "$check_dir" ] && [ -d "$check_dir" ]; then
        found=1
    elif [ -n "$check_cmd" ] && command -v "$check_cmd" &> /dev/null; then
        found=1
    fi

    if [ $found -eq 1 ]; then
        log_success "æ£€æµ‹åˆ° $name"
        if [ -n "$init_action" ]; then
            eval "$init_action"
        fi
        return 0
    fi
    return 1
}

# ------------------------------------------------------------------------------
# Command: init
# ------------------------------------------------------------------------------
cmd_init() {
    log_info "æ­£åœ¨åˆå§‹åŒ– ASH ç¯å¢ƒ..."
    
    # 1. Google Antigravity
    detect_ide "Google Antigravity" "$HOME_DIR/.agent" "" "mkdir -p \"$AGENT_SKILLS_DIR\""

    # 2. Cursor
    detect_ide "Cursor" "$HOME_DIR/.cursor" "cursor" "mkdir -p \"$CURSOR_SKILLS_DIR\""

    # 3. TRAE
    detect_ide "TRAE" "$HOME_DIR/.trae" "trae" "mkdir -p \"$TRAE_SKILLS_DIR\""

    # 4. Windsurf
    detect_ide "Windsurf" "$HOME_DIR/.windsurf" "windsurf" "mkdir -p \"$WINDSURF_SKILLS_DIR\""

    # 5. VS Code + Copilot
    detect_ide "VS Code + Copilot" "$HOME_DIR/.copilot" "" "mkdir -p \"$COPILOT_SKILLS_DIR\""

    # 6. Claude Code
    detect_ide "Claude Code" "$HOME_DIR/.claude" "claude" "mkdir -p \"$CLAUDE_SKILLS_DIR\""

    # 7. Trae CN (Chinese Version)
    detect_ide "Trae CN" "$HOME_DIR/.trae-cn" "trae" "mkdir -p \"$TRAE_CN_SKILLS_DIR\""

    log_success "åˆå§‹åŒ–å®Œæˆã€‚"
}

# ------------------------------------------------------------------------------
# Command: sync
# ------------------------------------------------------------------------------
cmd_sync() {
    log_info "æ­£åœ¨åŒæ­¥æŠ€èƒ½åº“..."
    
    # 1. å¦‚æœåœ¨é¡¹ç›®ç›®å½•ä¸‹ï¼Œå…ˆæ‹‰å–æœ€æ–°ä»£ç 
    if [ -d "$PROJECT_ROOT/.git" ]; then
        log_info "æ­£åœ¨ä»è¿œç¨‹ä»“åº“æ‹‰å–æ›´æ–° ($PROJECT_ROOT)..."
        (cd "$PROJECT_ROOT" && git pull origin main)
        
        # 2. åŒæ­¥åˆ°å…¨å±€ç›®å½•
        log_info "æ­£åœ¨åŒæ­¥åˆ°å…¨å±€ä¸»ç›®å½• ($SKILLS_DIR)..."
        cp -r "$PROJECT_ROOT/skills/"* "$SKILLS_DIR/"
    else
        log_warn "æœªåœ¨é¡¹ç›®æ ¹ç›®å½•è¿è¡Œï¼Œå°†è·³è¿‡æœ¬åœ°ä»“åº“åŒæ­¥ã€‚"
        log_info "å¦‚æœæ‚¨æƒ³ç›´æ¥ä»è¿œç¨‹åŒæ­¥åˆ°å…¨å±€ï¼Œè¯·å…‹éš†é¡¹ç›®å¹¶è¿è¡Œ install.shã€‚"
    fi
    
    log_success "åŒæ­¥å®Œæˆï¼æ‚¨å¯ä»¥è¿è¡Œ 'ash list' æŸ¥çœ‹æœ€æ–°æŠ€èƒ½ã€‚"
}

# ------------------------------------------------------------------------------
# Command: list
# ------------------------------------------------------------------------------
cmd_list() {
    log_info "å¯ç”¨æŠ€èƒ½åˆ—è¡¨:"
    echo ""
    
    local count=0
    local skill_list=()

    # ç¬¬ä¸€æ­¥ï¼šæ”¶é›†å¹¶å¤„ç†æ‰€æœ‰æŠ€èƒ½ä¿¡æ¯
    while IFS= read -r path; do
        local filename=$(basename "$path")
        
        # å¦‚æœæ˜¯ç›®å½•ï¼Œæ˜¾ç¤ºç›®å½•åï¼›å¦‚æœæ˜¯æ–‡ä»¶ï¼Œæ˜¾ç¤ºæ–‡ä»¶å
        # å› ä¸º get_all_skills å·²ç»è¿”å›äº†æ­£ç¡®çš„ç›®å½•è·¯å¾„ï¼ˆé’ˆå¯¹Folder Skillï¼‰
        # æ‰€ä»¥è¿™é‡Œåªéœ€è¦å– basename å³å¯
        skill_list+=("$filename")
        
    done < <(get_all_skills)
    
    # ç¬¬äºŒæ­¥ï¼šæ’åºï¼ˆçº¯å­—æ¯åºï¼‰
    local IFS=$'\n'
    local sorted_skills=($(sort <<<"${skill_list[*]}"))
    unset IFS

    # ç¬¬ä¸‰æ­¥ï¼šå¹³é“ºè¾“å‡º
    for filename in "${sorted_skills[@]}"; do
        echo -e "  ${GREEN}â€¢${NC} ${CYAN}$filename${NC}"
        ((count++))
    done
    
    echo ""
    log_info "å…± $count ä¸ªæŠ€èƒ½å¯ç”¨"
    echo -e "${DIM}æç¤º: ä½¿ç”¨ 'ash info <æŠ€èƒ½å>' æŸ¥çœ‹è¯¦ç»†æè¿°${NC}"
}

# ------------------------------------------------------------------------------
# Command: info
# ------------------------------------------------------------------------------
cmd_info() {
    local skill_name="$1"
    if [ -z "$skill_name" ]; then
        log_error "è¯·æä¾›æŠ€èƒ½åç§° (ä¾‹å¦‚: ash info pdf)"
        return 1
    fi

    local source_file; source_file=$(resolve_skill_path "$skill_name")
    local ret=$?
    
    if [ $ret -eq 0 ]; then
        # Handle Directory Skill: Use SKILL.md for info
        local content_file="$source_file"
        if [ -d "$source_file" ]; then
            content_file="$source_file/SKILL.md"
        fi

        local rel_path="${source_file#$SKILLS_DIR/}"
        echo -e "${CYAN}æŠ€èƒ½:${NC} $rel_path"
        
        # Extract description from content file
        local desc=$(extract_description "$content_file")
        echo -e "${GREEN}æè¿°:${NC} ${desc:-"(æ— æè¿°)"}"
        
        echo -e "${DIM}å†…å®¹é¢„è§ˆ:${NC}"
        if [ "$(head -n 1 "$content_file" 2>/dev/null)" == "---" ]; then
            sed '1,/---/d' "$content_file" | grep -v "^---" | head -n 10 | sed 's/^/  /'
        else
            head -n 10 "$content_file" | sed 's/^/  /'
        fi
    elif [ $ret -eq 1 ]; then
        log_error "æœªæ‰¾åˆ°åŒ¹é…çš„æŠ€èƒ½: $skill_name"
        return 1
    fi
}

# ------------------------------------------------------------------------------
# Command: search
# ------------------------------------------------------------------------------
cmd_search() {
    local keyword="$1"
    if [ -z "$keyword" ]; then
        log_error "è¯·æä¾›å…³é”®è¯è¿›è¡Œæœç´¢ (ä¾‹å¦‚: ash search react)"
        return 1
    fi

    log_info "æ­£åœ¨æœç´¢å…³é”®è¯: '$keyword' ..."
    echo ""

    local count=0
    while IFS= read -r item; do
        rel_path="${item#$SKILLS_DIR/}"
        
        # Resolve actual content file for description extraction
        local content_file="$item"
        if [ -d "$item" ]; then
            content_file="$item/SKILL.md"
        fi
        
        # è·å–æè¿°
        first_line=$(extract_description "$content_file")
        
        # åœ¨è·¯å¾„æˆ–æè¿°ä¸­æœç´¢ (ä¸åŒºåˆ†å¤§å°å†™)
        if echo "$rel_path $first_line" | grep -iq "$keyword"; then
            # Display: Use basename for cleaner output (like list) or rel_path?
            # User likely wants to see the skill name clearly.
            # list uses basename. search used rel_path.
            # Let's use basename for consistency, maybe showing parent dir in parens?
            local filename=$(basename "$item")
            
            echo -e "  ${GREEN}â€¢${NC} ${CYAN}$filename${NC} ${DIM}($rel_path)${NC}"
            if [ -n "$first_line" ]; then
                echo -e "    $first_line"
            fi
            ((count++))
        fi
    done < <(get_all_skills)

    if [ $count -eq 0 ]; then
        log_warn "æœªæ‰¾åˆ°åŒ¹é…çš„æŠ€èƒ½: $keyword"
    else
        echo ""
        log_info "æ‰¾åˆ° $count ä¸ªåŒ¹é…é¡¹"
    fi
}

# ------------------------------------------------------------------------------
# Command: status
# ------------------------------------------------------------------------------
cmd_status() {
    log_info "å·²å®‰è£…æŠ€èƒ½çŠ¶æ€:"
    echo ""
    
    local found=0
    
    # Helper to check an IDE dir
    check_ide_status() {
        local ide_name="$1"
        local dir="$2"
        local found_in_ide=0
        
        if [ -d "$dir" ]; then
            echo -e "  ${CYAN}${ide_name} ($dir):${NC}"
            
            # Enable nullglob to handle empty dirs correctly if no matches
            shopt -s nullglob
            # Capture all symlinks (files or dirs)
            local links=("$dir"/*)
            shopt -u nullglob
            
            for link in "${links[@]}"; do
                if [ -L "$link" ]; then
                    local target=$(readlink "$link")
                    local name=$(basename "$link")
                    echo -e "    ${GREEN}â€¢${NC} $name -> $target"
                    ((found_in_ide++))
                fi
            done
            
            if [ $found_in_ide -eq 0 ]; then
                echo -e "    ${YELLOW}(æ— )${NC}"
            fi
        fi
    }

    check_ide_status "Antigravity" "$AGENT_SKILLS_DIR"
    check_ide_status "Cursor" "$CURSOR_SKILLS_DIR"
    check_ide_status "TRAE" "$TRAE_SKILLS_DIR"
    check_ide_status "Windsurf" "$WINDSURF_SKILLS_DIR"
    check_ide_status "VS Code + Copilot" "$COPILOT_SKILLS_DIR"
    check_ide_status "Claude" "$CLAUDE_SKILLS_DIR"
    check_ide_status "Trae CN" "$TRAE_CN_SKILLS_DIR"
    
    echo ""
}

# ------------------------------------------------------------------------------
# Command: clean
# ------------------------------------------------------------------------------
cmd_clean() {
    local target="$1"
    
    # å®šä¹‰ IDE åç§°åŠå…¶å¯¹åº”çš„è·¯å¾„ (éœ€ä¸ install_skill_file ä¿æŒä¸€è‡´)
    local ide_names=("Antigravity" "Cursor" "TRAE" "Windsurf" "Copilot" "Claude" "Trae CN")
    local dirs=("$AGENT_SKILLS_DIR" "$CURSOR_SKILLS_DIR" "$TRAE_SKILLS_DIR" "$WINDSURF_SKILLS_DIR" "$COPILOT_SKILLS_DIR" "$CLAUDE_SKILLS_DIR" "$TRAE_CN_SKILLS_DIR")
    
    if [ -z "$target" ]; then
        echo -e "ç”¨æ³•: ash clean <ide_name> æˆ– ash clean --all"
        echo -e "å¯ç”¨ IDE: [${ide_names[*]}]"
        return 1
    fi

    # ç¡®è®¤æ“ä½œ
    echo -e "${YELLOW}è­¦å‘Š: æ­¤æ“ä½œå°†åˆ é™¤ç›®æ ‡ç›®å½•ä¸‹çš„æ‰€æœ‰æŠ€èƒ½é“¾æ¥ (ä¸ä¼šåˆ é™¤æºæ–‡ä»¶)ã€‚${NC}"
    read -p "ç¡®å®šè¦ç»§ç»­å—? [y/N] " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "å·²å–æ¶ˆã€‚"
        return 0
    fi

    local cleaned_any=0

    # Clean Logic
    clean_dir() {
        local dir="$1"
        local name="$2"
        
        if [ ! -d "$dir" ]; then
            # echo "Skipping $name: directory not found."
            return
        fi

        # Find count first
        local count=$(find "$dir" -maxdepth 1 -type l | wc -l | tr -d ' ')
        if [ "$count" -gt 0 ]; then
            # åªåˆ é™¤è½¯é“¾æ¥ï¼Œä¿ç•™ç”¨æˆ·å¯èƒ½æ‰‹åŠ¨æ”¾å…¥çš„å®ä½“æ–‡ä»¶ (å®‰å…¨èµ·è§)
            find "$dir" -maxdepth 1 -type l -delete
            log_success "å·²æ¸…ç©º $name æŠ€èƒ½ç›®å½• ($count ä¸ªé“¾æ¥å·²ç§»é™¤)ã€‚"
            ((cleaned_any++))
        else
            echo -e "${DIM}  $name: å·²ç»æ˜¯ç©ºçš„ã€‚${NC}"
        fi
    }

    if [ "$target" == "--all" ]; then
        for i in "${!ide_names[@]}"; do
            clean_dir "${dirs[$i]}" "${ide_names[$i]}"
        done
    else
        # Fuzzy match target name
        local found_target=0
        for i in "${!ide_names[@]}"; do
            # Case insensitive match (Bash 3.2 compatible)
            local ide_lower=$(echo "${ide_names[$i]}" | tr '[:upper:]' '[:lower:]')
            local target_lower=$(echo "${target}" | tr '[:upper:]' '[:lower:]')
            
            if [[ "$ide_lower" == "$target_lower" ]]; then
                clean_dir "${dirs[$i]}" "${ide_names[$i]}"
                found_target=1
                break
            fi
        done
        
        if [ $found_target -eq 0 ]; then
            log_error "æœªæ‰¾åˆ°åä¸º '$target' çš„ IDEã€‚"
            echo "å¯ç”¨åç§°: ${ide_names[*]}"
            return 1
        fi
    fi
    
    if [ $cleaned_any -eq 0 ]; then
        log_warn "æ²¡æœ‰æ‰§è¡Œä»»ä½•æ¸…ç†æ“ä½œ (ç›®å½•ä¸ºç©ºæˆ–ä¸å­˜åœ¨)ã€‚"
    fi
}


# ------------------------------------------------------------------------------
# Command: install
# ------------------------------------------------------------------------------
# è¾…åŠ©å‡½æ•°: å®‰è£…å•ä¸ªæŠ€èƒ½æ–‡ä»¶åˆ°æ‰€æœ‰æ£€æµ‹åˆ°çš„ IDE
# è¾…åŠ©å‡½æ•°: å®‰è£…å•ä¸ªæŠ€èƒ½(æ–‡ä»¶ æˆ– æ–‡ä»¶å¤¹)åˆ°æ‰€æœ‰æ£€æµ‹åˆ°çš„ IDE
install_skill_file() {
    local source_path="$1"
    local installed=0
    local filename=$(basename "$source_path")
    
    # æ£€æµ‹æ˜¯æ–‡ä»¶è¿˜æ˜¯æ–‡ä»¶å¤¹
    local is_dir=0
    if [ -d "$source_path" ]; then
        is_dir=1
    fi

    # å®šä¹‰ IDE ç›®å½•æ˜ å°„
    local targets=("$AGENT_SKILLS_DIR" "$CURSOR_SKILLS_DIR" "$TRAE_SKILLS_DIR" "$WINDSURF_SKILLS_DIR" "$COPILOT_SKILLS_DIR" "$CLAUDE_SKILLS_DIR" "$TRAE_CN_SKILLS_DIR")
    # å®šä¹‰å¯¹åº”æ˜¾ç¤ºçš„ IDE åç§°
    local ide_names=("Antigravity" "Cursor" "TRAE" "Windsurf" "Copilot" "Claude" "Trae CN")
    
    local installed_ides=()

    for i in "${!targets[@]}"; do
        local target_dir="${targets[$i]}"
        local ide_name="${ide_names[$i]}"
        
        if [ -d "$target_dir" ]; then
            local dest="$target_dir/$filename"
            
            # ä½¿ç”¨ ln -sfn å¼ºåˆ¶æ›´æ–°é“¾æ¥ (æ”¯æŒç›®å½•å’Œæ–‡ä»¶)
            ln -sfn "$source_path" "$dest"
            ((installed++))
            installed_ides+=("$ide_name")
        fi
    done

    if [ $installed -gt 0 ]; then
        local type_label="æ–‡ä»¶"
        [ $is_dir -eq 1 ] && type_label="ç›®å½•åŒ…"
        
        log_success "å·²å®‰è£… $type_label: $filename (${source_path#$SKILLS_DIR/})"
        echo -e "  ${DIM}â†³ åŒæ­¥è‡³ ${installed} ä¸ª IDE: [${CYAN}${ides_str}${DIM}]${NC}"
    fi
    return $installed
}

# ------------------------------------------------------------------------------
# Project Mode Helper: Bridge IDE Rules
# ç¡®ä¿å…¶ä»– IDE (Cursor, Windsurf, TRAE, Agent, etc.) èƒ½çœ‹åˆ° .claude/skills ä¸­çš„æŠ€èƒ½
# ------------------------------------------------------------------------------
bridge_ide_rules() {
    local project_root="$1"
    local skill_name="$2"     # e.g., "java.md"
    local source_file="$3"    # Absolute path to skill in .claude/skills/

    # å®šä¹‰ IDE é…ç½®æ˜ å°„
    # Logic: If project_root/.<ide> exists, create .<ide>/skills link
    local ide_dirs=("cursor" "windsurf" "trae" "trae-cn" "agent" "copilot")
    local ide_names=("Cursor" "Windsurf" "TRAE" "Trae CN" "Antigravity" "Copilot")

    for i in "${!ide_dirs[@]}"; do
        local dir_name=".${ide_dirs[$i]}"     # e.g., .cursor
        local pretty_name="${ide_names[$i]}"  # e.g., Cursor
        
        if [ -d "$project_root/$dir_name" ]; then
            local skills_dir="$project_root/$dir_name/skills"
            mkdir -p "$skills_dir"
            
            local target="$skills_dir/$skill_name"
            # Link to .claude source
            ln -sf "$source_file" "$target"
            log_info "  â†³ Bridge ($pretty_name): $dir_name/skills/$skill_name -> .claude"
        fi
    done
}

# ------------------------------------------------------------------------------
# Project Mode Core: Install to Project
# ------------------------------------------------------------------------------
install_to_project() {
    local skill_path="$1"
    local project_path="$2"
    
    # 1. ç¡®å®šé¡¹ç›®æ ¹ç›®å½•
    if [ -z "$project_path" ]; then
        project_path=$(pwd)
    fi
    # Resolve absolute path for project_path
    project_path=$(cd "$project_path" && pwd)

    local filename=$(basename "$skill_path")
    
    # 2. å»ºç«‹æ ‡å‡†å­˜å‚¨: .claude/skills (Single Source of Truth)
    local claude_skills="$project_path/.claude/skills"
    mkdir -p "$claude_skills"
    
    local target="$claude_skills/$filename"
    
    # 3. å®‰è£…åˆ° .claude/skills
    ln -sfn "$skill_path" "$target"
    log_success "å·²å®‰è£…åˆ°é¡¹ç›®: ${CYAN}.claude/skills/$filename${NC}"
    
    # 4. å»ºç«‹ IDE æ¡¥æ¥
    bridge_ide_rules "$project_path" "$filename" "$target"
}

# ------------------------------------------------------------------------------
# Command: install
# ------------------------------------------------------------------------------
cmd_install() {
    local skill_name="$1"
    local mode="global"
    local project_path=""
    
    # Parse Arguments manually since we have optional flags
    shift # Remove first arg (skill_name)
    
    while [[ "$#" -gt 0 ]]; do
        case $1 in
            -p|--project)
                mode="project"
                if [[ -n "$2" && "$2" != -* ]]; then
                    project_path="$2"
                    shift
                fi
                ;;
            *)
                ;;
        esac
        shift
    done

    if [ -z "$skill_name" ]; then
        log_error "è¯·æŒ‡å®šè¦å®‰è£…çš„æŠ€èƒ½åç§°ã€‚"
        echo "ç”¨æ³•: ash install <name> [-p [path]]"
        return 1
    fi

    # Handle --all
    if [ "$skill_name" == "--all" ]; then
        # è·å–æ‰€æœ‰å¾…å®‰è£…çš„æŠ€èƒ½æ–‡ä»¶ (ä½¿ç”¨é€šç”¨è¿‡æ»¤å‡½æ•°)
        local skill_files=()
        while IFS= read -r path; do
            skill_files+=("$path")
        done < <(get_all_skills)
        
        local skill_count=${#skill_files[@]}
        
        # --- Project Mode Batch Install ---
        if [ "$mode" == "project" ]; then
             log_info "æ­£åœ¨æ‰¹é‡å®‰è£… $skill_count ä¸ªæŠ€èƒ½åˆ°é¡¹ç›®..."
             echo ""
             for file in "${skill_files[@]}"; do
                install_to_project "$file" "$project_path"
             done
             echo ""
             log_success "é¡¹ç›®çº§æ‰¹é‡å®‰è£…å®Œæˆï¼"
             return 0
        fi

        # --- Global Mode Batch Install ---
        log_info "æ­£åœ¨æ‰¹é‡å®‰è£… $skill_count ä¸ªæŠ€èƒ½åˆ°æ‰€æœ‰æ£€æµ‹åˆ°çš„ IDE..."
        echo ""

        # å®šä¹‰ IDE åç§°åŠå…¶å¯¹åº”çš„è·¯å¾„
        local ides=("Antigravity" "Cursor" "TRAE" "Windsurf" "Copilot" "Claude" "Trae CN")
        local dirs=("$AGENT_SKILLS_DIR" "$CURSOR_SKILLS_DIR" "$TRAE_SKILLS_DIR" "$WINDSURF_SKILLS_DIR" "$COPILOT_SKILLS_DIR" "$CLAUDE_SKILLS_DIR" "$TRAE_CN_SKILLS_DIR")
        
        local updated_ides=()
        local total_links=0
        
        # é€ä¸ªå®‰è£…æŠ€èƒ½å¹¶æ˜¾ç¤ºåˆ—è¡¨é£æ ¼çš„è¿›åº¦
        for file in "${skill_files[@]}"; do
            local filename=$(basename "$file")
            local rel_path="${file#$SKILLS_DIR/}"
            echo -e "  ${GREEN}â€¢${NC} ${CYAN}$filename${NC} ${DIM}($rel_path)${NC}"
            
            for i in "${!ides[@]}"; do
                local dir="${dirs[$i]}"
                if [ -d "$dir" ]; then
                    # Force link creation (directory or file)
                    ln -sfn "$file" "$dir/$filename"
                    ((total_links++))
                fi
            done
        done

        # ç»Ÿè®¡æœ‰æ•ˆ IDE
        for i in "${!ides[@]}"; do
            [ -d "${dirs[$i]}" ] && updated_ides+=("${ides[$i]}")
        done
        
        echo ""
        if [ ${#updated_ides[@]} -gt 0 ]; then
            local ides_list=$(IFS=,; echo "${updated_ides[*]}")
            log_success "æ‰¹é‡å®‰è£…å®Œæˆï¼"
            echo -e "  ${CYAN}å·²åŒæ­¥ IDE:${NC} ${ides_list//,/ã€}"
            echo -e "  ${CYAN}æ€»é“¾æ¥æ•°:${NC} $total_links"
        else
            log_warn "æœªæ£€æµ‹åˆ°æ”¯æŒçš„ IDE ç¯å¢ƒï¼Œè¯·å…ˆè¿è¡Œ 'ash init'"
        fi
        return 0
    fi

    # --- Existing Logic for Resolution ---
    local skill_path
    skill_path=$(resolve_skill_path "$skill_name")
    local status=$?
    
    if [ $status -ne 0 ]; then
        if [ $status -eq 1 ]; then
            log_error "æœªæ‰¾åˆ°æŠ€èƒ½: '$skill_name'"
            # Suggestion Logic
            local best_match=$(find "$SKILLS_DIR" -name "*.md" | xargs basename | grep -i "$skill_name" | head -n 1)
             if [ -n "$best_match" ]; then
                echo -e "ğŸ’¡ æ‚¨æ˜¯ä¸æ˜¯æƒ³å®‰è£…: ${CYAN}${best_match%.md}${NC} ?"
            fi
        fi
        return 1
    fi

    # --- Execution ---
    if [ "$mode" == "project" ]; then
        install_to_project "$skill_path" "$project_path"
    else
        # Global Install (Original Logic)
        local filename=$(basename "$skill_path")
        local rel_path="${skill_path#$SKILLS_DIR/}"
        
        log_success "å·²å®‰è£… ${CYAN}$filename${NC} ($rel_path)"
        
        local count=0
        local updated_ides=() # Use array to store list
        
        # ... (Existing loop for global IDEs) ...
        local ides=("Antigravity" "Cursor" "TRAE" "Windsurf" "Copilot" "Claude" "Trae CN")
        local dirs=("$AGENT_SKILLS_DIR" "$CURSOR_SKILLS_DIR" "$TRAE_SKILLS_DIR" "$WINDSURF_SKILLS_DIR" "$COPILOT_SKILLS_DIR" "$CLAUDE_SKILLS_DIR" "$TRAE_CN_SKILLS_DIR")
        
        for i in "${!ides[@]}"; do
            local ide_name="${ides[$i]}"
            local dir="${dirs[$i]}"
            
            if [ -d "$dir" ]; then
                # Force link creation (ln -sf for file, ln -sfn for dir)
                ln -sfn "$skill_path" "$dir/$filename"
                ((count++))
                updated_ides+=("$ide_name")
            fi
        done
        
        if [ $count -gt 0 ]; then
             # Format the array output properly e.g. [Cursor, Claude]
             local ide_list_str=$(IFS=, ; echo "${updated_ides[*]}")
             ide_list_str=$(echo "$ide_list_str" | sed 's/,/, /g')
             echo -e "  â†³ åŒæ­¥è‡³ $count ä¸ª IDE: [${GREEN}$ide_list_str${NC}]"
        else
            log_warn "æœªæ£€æµ‹åˆ°ä»»ä½•å·²åˆå§‹åŒ–çš„ IDE æŠ€èƒ½ç›®å½•ã€‚"
            echo "æç¤º: è¯·å…ˆè¿è¡Œ 'ash init' æˆ–æ‰‹åŠ¨åˆ›å»ºç›®å½•ã€‚"
        fi
    fi
}

# ------------------------------------------------------------------------------
# Helper: Remove all skill links from all IDEs
# ------------------------------------------------------------------------------
remove_all_links() {
    log_info "æ­£åœ¨ä»æ‰€æœ‰ IDE å¸è½½æ‰€æœ‰æŠ€èƒ½..."
    local total_count=0
    
    # å®šä¹‰ IDE åç§°åŠå…¶å¯¹åº”çš„è·¯å¾„
    local ides=("Antigravity" "Cursor" "TRAE" "Windsurf" "Copilot" "Claude" "Trae CN")
    local dirs=("$AGENT_SKILLS_DIR" "$CURSOR_SKILLS_DIR" "$TRAE_SKILLS_DIR" "$WINDSURF_SKILLS_DIR" "$COPILOT_SKILLS_DIR" "$CLAUDE_SKILLS_DIR" "$TRAE_CN_SKILLS_DIR")
    
    for i in "${!ides[@]}"; do
        local ide_name="${ides[$i]}"
        local dir="${dirs[$i]}"
        local ide_count=0
        local removed_skills=()
        
        if [ -d "$dir" ]; then
            # è®°å½•è¯¥ IDE ä¸‹ç§»é™¤çš„æ‰€æœ‰æŠ€èƒ½
            for link in "$dir"/*.md; do
                if [ -L "$link" ]; then
                    local filename=$(basename "$link")
                    rm "$link"
                    removed_skills+=("$filename")
                    ((ide_count++))
                    ((total_count++))
                fi
            done
            
            # è¾“å‡ºè¯¥ IDE çš„ç»“æœ
            if [ $ide_count -gt 0 ]; then
                # å°†æ•°ç»„è½¬æ¢ä¸ºé€—å·åˆ†éš”çš„å­—ç¬¦ä¸²
                local skills_list=$(IFS=,; echo "${removed_skills[*]}")
                echo -e "  ${CYAN}$ide_name:${NC} å·²ç§»é™¤ ${GREEN}$ide_count${NC} ä¸ªæŠ€èƒ½ [${DIM}${skills_list//,/ã€}${NC}]"
            fi
        fi
    done
    
    echo ""
    if [ $total_count -gt 0 ]; then
        log_success "å…¨é‡å¸è½½å®Œæˆï¼Œå…±ä»æ‰€æœ‰ IDE ä¸­ç§»é™¤äº† $total_count ä¸ªé“¾æ¥ã€‚"
    else
        log_warn "æœªå‘ç°ä»»ä½•å·²å®‰è£…çš„æŠ€èƒ½é“¾æ¥ã€‚"
    fi
}

# ------------------------------------------------------------------------------
# Command: uninstall
# ------------------------------------------------------------------------------
cmd_uninstall() {
    local skill_name="$1"
    
    if [ "$skill_name" == "--all" ]; then
        remove_all_links
        return 0
    fi
    
    if [ -z "$skill_name" ]; then
        log_error "è¯·æŒ‡å®šè¦å¸è½½çš„æŠ€èƒ½åç§° (ä¾‹å¦‚: expert æˆ– expert.mdï¼Œæˆ–ä½¿ç”¨ --all)"
        return 1
    fi
    
    local removed=0
    
    # å®šä¹‰ IDE åç§°åŠå…¶å¯¹åº”çš„è·¯å¾„
    local ides=("Antigravity" "Cursor" "TRAE" "Windsurf" "Copilot" "Claude" "Trae CN")
    local dirs=("$AGENT_SKILLS_DIR" "$CURSOR_SKILLS_DIR" "$TRAE_SKILLS_DIR" "$WINDSURF_SKILLS_DIR" "$COPILOT_SKILLS_DIR" "$CLAUDE_SKILLS_DIR" "$TRAE_CN_SKILLS_DIR")
    
    for i in "${!ides[@]}"; do
        local ide_name="${ides[$i]}"
        local dir="${dirs[$i]}"
        
        if [ -d "$dir" ]; then
            # 1. å°è¯•ç§»é™¤å®Œå…¨åŒ¹é…çš„åç§° (ç”¨äºæ–‡ä»¶å¤¹å‹æŠ€èƒ½ æˆ– æ˜¾å¼å¸¦åç¼€çš„æ–‡ä»¶)
            local link="$dir/$skill_name"
            if [ -L "$link" ]; then
                rm "$link"
                log_success "å·²ä» $ide_name ç§»é™¤: $skill_name"
                ((removed++))
            fi
            
            # 2. å¦‚æœè¾“å…¥ä¸å¸¦ .mdï¼Œå°è¯•ç§»é™¤å¸¦ .md åç¼€çš„æ–‡ä»¶
            if [[ "$skill_name" != *.md ]]; then
                local link_md="$dir/${skill_name}.md"
                if [ -L "$link_md" ]; then
                    rm "$link_md"
                    log_success "å·²ä» $ide_name ç§»é™¤: ${skill_name}.md"
                    ((removed++))
                fi
            fi
        fi
    done
    
    if [ $removed -eq 0 ]; then
        log_warn "æœªæ‰¾åˆ°å·²å®‰è£…çš„æŠ€èƒ½: $skill_name"
    fi
}


# ------------------------------------------------------------------------------
# Main Dispatch
# ------------------------------------------------------------------------------
case "$1" in
    init)
        cmd_init
        ;;
    list)
        cmd_list
        ;;
    info)
        shift
        cmd_info "$@"
        ;;
    search)
        shift
        cmd_search "$@"
        ;;
    status)
        cmd_status
        ;;
    install)
        shift
        cmd_install "$@"
        ;;
    uninstall)
        shift
        cmd_uninstall "$@"
        ;;
    clean)
        shift
        cmd_clean "$@"
        ;;
    sync)
        cmd_sync
        ;;
    -v|--version)
        show_version
        ;;
    -h|--help)
        show_help
        ;;
    "")
        show_help
        ;;
    *)
        command="$1"
        log_error "æœªçŸ¥å‘½ä»¤: '$command'"
        
        # æ™ºèƒ½å»ºè®®é€»è¾‘
        case "$command" in
            intall|insall|instal)
                echo -e "ğŸ’¡ æ‚¨æ˜¯ä¸æ˜¯æƒ³è¾“å…¥: ${CYAN}ash install${NC} ?"
                ;;
            unintall|uninstal)
                echo -e "ğŸ’¡ æ‚¨æ˜¯ä¸æ˜¯æƒ³è¾“å…¥: ${CYAN}ash uninstall${NC} ?"
                ;;
            ls|lst)
                echo -e "ğŸ’¡ æ‚¨æ˜¯ä¸æ˜¯æƒ³è¾“å…¥: ${CYAN}ash list${NC} ?"
                ;;
            serch|find)
                echo -e "ğŸ’¡ æ‚¨æ˜¯ä¸æ˜¯æƒ³è¾“å…¥: ${CYAN}ash search${NC} ?"
                ;;
            stat|st)
                echo -e "ğŸ’¡ æ‚¨æ˜¯ä¸æ˜¯æƒ³è¾“å…¥: ${CYAN}ash status${NC} ?"
                ;;
            *)
                echo -e "è¯¦æƒ…è¯·è¿è¡Œ: ${DIM}ash --help${NC}"
                ;;
        esac
        exit 1
        ;;
esac
