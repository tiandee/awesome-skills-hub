#!/bin/bash

# ==============================================================================
# ASH (Awesome-Skills-Hub) CLI
# ==============================================================================
# A lightweight package manager for AI IDE skills.
# Author: Tiandee
# Version: 1.0.0
# ==============================================================================

VERSION="1.1.27"

# é¢œè‰²å®šä¹‰
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m'

# Logger Functions (Must be defined before use)
log_info() { echo -e "${BLUE}[ä¿¡æ¯]${NC} $1"; }
log_success() { echo -e "${GREEN}[æˆåŠŸ]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[è­¦å‘Š]${NC} $1"; }
log_error() { echo -e "${RED}[é”™è¯¯]${NC} $1"; }

# åŸºç¡€è·¯å¾„é…ç½®
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
ASH_HOME="$HOME/.ash"
SKILLS_DIR="$ASH_HOME/skills"

# Check if global skills exist. If not, initialize them from the package (First Run Logic)
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
# Debug path resolution
# echo "DEBUG: SCRIPT_DIR=$SCRIPT_DIR"
# echo "DEBUG: PROJECT_ROOT=$PROJECT_ROOT"

if [ ! -d "$SKILLS_DIR" ]; then
    LOCAL_SKILLS="$PROJECT_ROOT/skills"
    
    # Check if we can find the skills package
    if [ -d "$LOCAL_SKILLS" ]; then
        log_info "é¦–æ¬¡è¿è¡Œï¼Œæ­£åœ¨åˆå§‹åŒ–å…¨å±€ç¯å¢ƒ (~/.ash)..."
        log_info "ä» $LOCAL_SKILLS å¤åˆ¶æŠ€èƒ½..."
        
        mkdir -p "$ASH_HOME"
        cp -r "$LOCAL_SKILLS" "$SKILLS_DIR"
        
        if [ -d "$SKILLS_DIR" ]; then
            log_success "åˆå§‹åŒ–å®Œæˆï¼"
        else
            log_error "åˆå§‹åŒ–å¤±è´¥ï¼šå¤åˆ¶æ“ä½œæœªèƒ½åˆ›å»ºç›®æ ‡ç›®å½•ã€‚"
        fi
    else
        # Critical Debug Logic: why can't we find the skills?
        # log_warn "DEBUG: æœªåœ¨å®‰è£…åŒ…å†…æ‰¾åˆ° skills ç›®å½•: $LOCAL_SKILLS"
        # ls -F "$PROJECT_ROOT" # Try to see what IS there
        log_warn "æœªåœ¨å®‰è£…åŒ…å†…æ‰¾åˆ° skills ç›®å½•: $LOCAL_SKILLS"
        log_warn "æ‚¨å¯èƒ½éœ€è¦è¿è¡Œ 'ash sync' æˆ– 'git clone' æ¥è·å–æŠ€èƒ½ã€‚"
    fi
fi

# ç›®æ ‡è·¯å¾„é…ç½® (ä»…æ”¯æŒ Skills çš„å¹³å°)
HOME_DIR="$HOME"
AGENT_SKILLS_DIR="$HOME_DIR/.agent/skills"       # Google Antigravity
CURSOR_SKILLS_DIR="$HOME_DIR/.cursor/skills"     # Cursor
TRAE_SKILLS_DIR="$HOME_DIR/.trae/skills"         # TRAE
WINDSURF_SKILLS_DIR="$HOME_DIR/.windsurf/skills" # Windsurf
COPILOT_SKILLS_DIR="$HOME_DIR/.copilot/skills"   # VS Code + Copilot
CLAUDE_SKILLS_DIR="$HOME_DIR/.claude/skills"     # Claude Code
TRAE_CN_SKILLS_DIR="$HOME_DIR/.trae-cn/skills"   # Trae Chinese Version

# ------------------------------------------------------------------------------
# è¾…åŠ©å‡½æ•°: æå–æŠ€èƒ½æè¿° (æ”¯æŒ YAML å’Œ Markdown)
# ------------------------------------------------------------------------------
extract_description() {
    local file="$1"
    if [ ! -f "$file" ]; then return; fi
    
    # æ£€æŸ¥æ˜¯å¦åŒ…å« YAML å‰ç½®å…ƒæ•°æ®
    if [ "$(head -n 1 "$file" 2>/dev/null)" == "---" ]; then
        # ä» YAML ä¸­æå– description æˆ– name
        local desc=$(sed -n '/^description:/p' "$file" | head -n 1 | sed 's/^description:\s*//' | sed 's/^["\x27]//;s/["\x27]$//')
        if [ -n "$desc" ]; then
            echo "$desc"
            return
        fi
        local name=$(sed -n '/^name:/p' "$file" | head -n 1 | sed 's/^name:\s*//' | sed 's/^["\x27]//;s/["\x27]$//')
        if [ -n "$name" ]; then
            echo "$name"
            return
        fi
    fi
    
    # ä¼ ç»Ÿçš„ Markdown æ ‡é¢˜
    head -n 5 "$file" | grep "^# " | head -n 1 | sed 's/^#\s*//'
}

log_info() { echo -e "${BLUE}[ä¿¡æ¯]${NC} $1"; }
log_success() { echo -e "${GREEN}[æˆåŠŸ]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[è­¦å‘Š]${NC} $1"; }
log_error() { echo -e "${RED}[é”™è¯¯]${NC} $1"; }

show_version() {
    echo -e "${CYAN}ASH (Awesome-Skills-Hub) v${VERSION}${NC}"
    echo "AI IDE æŠ€èƒ½ç®¡ç†å·¥å…·"
}

show_help() {
    show_version
    echo ""
    echo -e "${YELLOW}ç”¨æ³•:${NC} ash <å‘½ä»¤> [å‚æ•°]"
    echo ""
    echo -e "${YELLOW}å‘½ä»¤:${NC}"
    echo "  init              åˆå§‹åŒ–ç¯å¢ƒå¹¶æ£€æµ‹å·²å®‰è£…çš„ IDE"
    echo "  list              åˆ—å‡ºæ‰€æœ‰å¯ç”¨æŠ€èƒ½"
    echo "  info <name>       æŸ¥çœ‹æŠ€èƒ½çš„è¯¦ç»†æè¿°å’Œå†…å®¹é¢„è§ˆ"
    echo "  search <keyword>  æ ¹æ®å…³é”®è¯æœç´¢æŠ€èƒ½"
    echo "  status            æ˜¾ç¤ºå·²å®‰è£…çš„æŠ€èƒ½"
    echo "  install <name>    å®‰è£…æŠ€èƒ½ (æ”¯æŒ -p å®‰è£…åˆ°å½“å‰é¡¹ç›®)"
    echo "  uninstall <name>  å¸è½½æŠ€èƒ½ (æ”¯æŒ --all å¸è½½å…¨éƒ¨)"
    echo "  clean <ide|--all> æ¸…ç©ºæŒ‡å®š IDE (æˆ–æ‰€æœ‰) çš„æŠ€èƒ½ç›®å½•"
    echo "  sync              åŒæ­¥æ›´æ–°æŠ€èƒ½ä»“åº“ (git pull)"
    echo ""
    echo -e "${YELLOW}é€‰é¡¹:${NC}"
    echo "  -p, --project [path]  (Install Only) å®‰è£…åˆ°é¡¹ç›®ç›®å½• (.claude/skills)"
    echo "  -v, --version         æ˜¾ç¤ºç‰ˆæœ¬ä¿¡æ¯"
    echo "  -h, --help            æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯"
    echo ""
    echo -e "${YELLOW}ç¤ºä¾‹:${NC}"
    echo "  ash init                      # åˆå§‹åŒ–å¹¶æ£€æµ‹ IDE"
    echo "  ash list                      # æŸ¥çœ‹æ‰€æœ‰æŠ€èƒ½"
    echo "  ash add pdf                   # å®‰è£…æŠ€èƒ½ (å…¨å±€)"
    echo "  ash add java -p               # å®‰è£…æŠ€èƒ½ (é¡¹ç›®çº§)"
    echo "  ash add --all -p              # æ‰¹é‡å®‰è£…æ‰€æœ‰æŠ€èƒ½åˆ°é¡¹ç›®"
    echo "  ash clean --all               # æ¸…ç©ºæ‰€æœ‰æŠ€èƒ½é“¾æ¥"
}

# ------------------------------------------------------------------------------
# è¾…åŠ©å‡½æ•°: æ™ºèƒ½è§£ææŠ€èƒ½è·¯å¾„
# ------------------------------------------------------------------------------
resolve_skill_path() {
    local input="$1"
    
    # helper: check if path is inside an existing folder skill
    is_inside_folder_skill() {
        local check_path="$1"
        local parent=$(dirname "$check_path")
        while [ "$parent" != "." ] && [ "$parent" != "/" ]; do
            if [ -f "$SKILLS_DIR/$parent/SKILL.md" ]; then
                return 0 # Yes, it's inside
            fi
            parent=$(dirname "$parent")
        done
        return 1 # No
    }

    # 1. å°è¯•ç›´æ¥åŒ¹é…è·¯å¾„
    local direct_path="$SKILLS_DIR/$input"
    
    # Check for Folder Skill (Must contain SKILL.md)
    if [ -d "$direct_path" ] && [ -f "$direct_path/SKILL.md" ]; then
        echo "$direct_path"
        return 0
    fi
    
    # Check for File Skill
    if [ -f "$direct_path" ]; then
        if ! is_inside_folder_skill "$input"; then
            echo "$direct_path"
            return 0
        fi
    fi
    if [ -f "${direct_path}.md" ]; then
        if ! is_inside_folder_skill "${input}.md"; then
            echo "${direct_path}.md"
            return 0
        fi
    fi
    
    # 2. æœç´¢ï¼šåŒæ—¶æŸ¥æ‰¾ .md æ–‡ä»¶å’Œç›®å½•å‹æŠ€èƒ½
    local matches=()
    
    # æŸ¥æ‰¾ .md æ–‡ä»¶
    while IFS= read -r file; do
        local rel="${file#$SKILLS_DIR/}"
        if ! is_inside_folder_skill "$rel"; then
            matches+=("$file")
        fi
    done < <(find "$SKILLS_DIR" -type f -name "${input}.md")
    
    # æŸ¥æ‰¾åŒåç›®å½• (å¿…é¡»åŒ…å« SKILL.md)
    while IFS= read -r dir; do
        if [ -f "$dir/SKILL.md" ]; then
            matches+=("$dir")
        fi
    done < <(find "$SKILLS_DIR" -type d -name "${input}")

    local count=${#matches[@]}
    
    if [ "$count" -eq 1 ]; then
        echo "${matches[0]}"
        return 0
    elif [ "$count" -gt 1 ]; then
        echo -e "${YELLOW}[è­¦å‘Š]${NC} å‘ç°å¤šä¸ªåŒ¹é…çš„æŠ€èƒ½ï¼Œè¯·å°è¯•ä½¿ç”¨å®Œæ•´è·¯å¾„å®‰è£…:" >&2
        for match in "${matches[@]}"; do
            local rel="${match#$SKILLS_DIR/}"
            echo -e "  - ${CYAN}ash add $rel${NC}" >&2
        done
        return 2 # å†²çª
    fi
    
    return 1 # æœªæ‰¾åˆ°
}

# ------------------------------------------------------------------------------
# è¾…åŠ©å‡½æ•°: è·å–æ‰€æœ‰å¯ç”¨æŠ€èƒ½åˆ—è¡¨ (å»é‡/è¿‡æ»¤)
# Returns: Array of valid skill paths (files or folder paths) printed to stdout
# ------------------------------------------------------------------------------
get_all_skills() {
    while IFS= read -r item; do
        local rel_path="${item#$SKILLS_DIR/}"
        local filename="${rel_path##*/}"

        # 1. Folder Skill (SKILL.md) -> Return parent dir
        if [ "$filename" = "SKILL.md" ]; then
            echo "$(dirname "$item")"
            continue
        fi

        # 2. Ordinary .md File
        if [ "$filename" == "README.md" ]; then continue; fi

        # 2.2 Shadowing & Nested Check (Recursive Parent Check)
        local parent=$(dirname "$rel_path")
        local is_nested=0
        
        # Check all parent directories up to root
        while [ "$parent" != "." ] && [ "$parent" != "/" ]; do
            if [ -f "$SKILLS_DIR/$parent/SKILL.md" ]; then
                is_nested=1
                break
            fi
            parent=$(dirname "$parent")
        done
        
        if [ $is_nested -eq 1 ]; then continue; fi
        
        # Also check if the file itself has a sibling directory skill (shadowing)
        local core_name="${filename%.md}"
        if [ -f "$SKILLS_DIR/$(dirname "$rel_path")/$core_name/SKILL.md" ]; then continue; fi
        
        echo "$item"
    done < <(find "$SKILLS_DIR" -type f -name "*.md" ! -name "README.md" | sort)
}

# ------------------------------------------------------------------------------
# IDE Detection Logic
# ------------------------------------------------------------------------------
detect_ide() {
    local name="$1"
    local check_dir="$2"
    local check_cmd="$3"
    local init_action="$4"

    local found=0
    if [ -n "$check_dir" ] && [ -d "$check_dir" ]; then
        found=1
    elif [ -n "$check_cmd" ] && command -v "$check_cmd" &> /dev/null; then
        found=1
    fi

    if [ $found -eq 1 ]; then
        log_success "æ£€æµ‹åˆ° $name"
        if [ -n "$init_action" ]; then
            eval "$init_action"
        fi
        return 0
    fi
    return 1
}

# ------------------------------------------------------------------------------
# Command: init
# ------------------------------------------------------------------------------
cmd_init() {
    log_info "æ­£åœ¨åˆå§‹åŒ– ASH ç¯å¢ƒ..."
    
    # 1. Google Antigravity
    detect_ide "Google Antigravity" "$HOME_DIR/.agent" "" "mkdir -p \"$AGENT_SKILLS_DIR\""

    # 2. Cursor
    detect_ide "Cursor" "$HOME_DIR/.cursor" "cursor" "mkdir -p \"$CURSOR_SKILLS_DIR\""

    # 3. TRAE
    detect_ide "TRAE" "$HOME_DIR/.trae" "trae" "mkdir -p \"$TRAE_SKILLS_DIR\""

    # 4. Windsurf
    detect_ide "Windsurf" "$HOME_DIR/.windsurf" "windsurf" "mkdir -p \"$WINDSURF_SKILLS_DIR\""

    # 5. VS Code + Copilot
    detect_ide "VS Code + Copilot" "$HOME_DIR/.copilot" "" "mkdir -p \"$COPILOT_SKILLS_DIR\""

    # 6. Claude Code
    detect_ide "Claude Code" "$HOME_DIR/.claude" "claude" "mkdir -p \"$CLAUDE_SKILLS_DIR\""

    # 7. Trae CN (Chinese Version)
    detect_ide "Trae CN" "$HOME_DIR/.trae-cn" "trae" "mkdir -p \"$TRAE_CN_SKILLS_DIR\""

    log_success "åˆå§‹åŒ–å®Œæˆã€‚"
}

# ------------------------------------------------------------------------------
# Command: sync
# ------------------------------------------------------------------------------
cmd_sync() {
    log_info "æ­£åœ¨åŒæ­¥æŠ€èƒ½åº“..."
    
    # 1. å¦‚æœåœ¨é¡¹ç›®ç›®å½•ä¸‹ï¼Œå…ˆæ‹‰å–æœ€æ–°ä»£ç 
    if [ -d "$PROJECT_ROOT/.git" ]; then
        log_info "æ­£åœ¨ä»è¿œç¨‹ä»“åº“æ‹‰å–æ›´æ–° ($PROJECT_ROOT)..."
        (cd "$PROJECT_ROOT" && git pull origin main)
        
        # 2. åŒæ­¥åˆ°å…¨å±€ç›®å½•
        log_info "æ­£åœ¨åŒæ­¥åˆ°å…¨å±€ä¸»ç›®å½• ($SKILLS_DIR)..."
        cp -r "$PROJECT_ROOT/skills/"* "$SKILLS_DIR/"
    else
        log_warn "æœªåœ¨é¡¹ç›®æ ¹ç›®å½•è¿è¡Œï¼Œå°†è·³è¿‡æœ¬åœ°ä»“åº“åŒæ­¥ã€‚"
        log_info "å¦‚æœæ‚¨æƒ³ç›´æ¥ä»è¿œç¨‹åŒæ­¥åˆ°å…¨å±€ï¼Œè¯·å…‹éš†é¡¹ç›®å¹¶è¿è¡Œ install.shã€‚"
    fi
    
    log_success "åŒæ­¥å®Œæˆï¼æ‚¨å¯ä»¥è¿è¡Œ 'ash list' æŸ¥çœ‹æœ€æ–°æŠ€èƒ½ã€‚"
    
    # --- Vercel Labs Integration ---
    import_from_vercel
}

# ------------------------------------------------------------------------------
# Helper: Import from Vercel/Agents (~/.agents/skills)
# ------------------------------------------------------------------------------
import_from_vercel() {
    local vercel_dir="$HOME/.agents/skills"
    
    # 1. Check if Vercel directory exists
    if [ ! -d "$vercel_dir" ]; then
        return
    fi
    
    # 2. Find new skills (not present in ~/.ash/skills)
    local new_skills=()
    local count=0
    
    # Iterate over files/dirs in ~/.agents/skills
    for item in "$vercel_dir"/*; do
        [ -e "$item" ] || continue
        
        local name=$(basename "$item")
        
        # Skip if already exists in ASH (Recursive Shadow Check)
        if resolve_skill_path "$name" > /dev/null 2>&1; then
            continue
        fi
        
        new_skills+=("$item")
        ((count++))
    done
    
    if [ $count -eq 0 ]; then
        return
    fi
    
    echo ""
    log_info "ğŸ” å‘ç°æ¥è‡ª Vercel/Agents ç”Ÿæ€çš„æ–°æŠ€èƒ½ ($count ä¸ª):"
    for item in "${new_skills[@]}"; do
        echo -e "  ${GREEN}+${NC} $(basename "$item")"
    done
    echo ""
    
    # 3. Ask for import
    echo -e "${YELLOW}æ˜¯å¦å°†è¿™äº›æŠ€èƒ½å¯¼å…¥ ASH å¹¶åˆ†å‘åˆ°æ‰€æœ‰ IDE?${NC}"
    read -p "ç¡®è®¤å¯¼å…¥? [Y/n] " confirm
    if [[ "$confirm" == "n" || "$confirm" == "N" ]]; then
        echo "å·²è·³è¿‡å¯¼å…¥ã€‚"
        return
    fi
    
    # 4. Import & Bridge
    local success_count=0
    for source in "${new_skills[@]}"; do
        local name=$(basename "$source")
        local target="$SKILLS_DIR/$name"
        
        # Strategy: Copy (Fork) to own the config
        cp -r "$source" "$target"
        
        if [ $? -eq 0 ]; then
            log_success "å·²å¯¼å…¥: $name"
            
            # Trigger Bridge Engine (Install to all IDEs)
            install_skill_file "$target" > /dev/null
            ((success_count++))
        else
            log_error "å¯¼å…¥å¤±è´¥: $name"
        fi
    done
    
    if [ $success_count -gt 0 ]; then
        echo ""
        log_success "æˆåŠŸå¯¼å…¥å¹¶åˆ†å‘äº† $success_count ä¸ªå¤–éƒ¨æŠ€èƒ½ï¼"
        echo -e "æç¤º: æ‚¨ç°åœ¨å¯ä»¥ä½¿ç”¨ ${CYAN}ash info <name>${NC} æ¥æŸ¥çœ‹å®ƒä»¬ã€‚"
    fi
}
# ------------------------------------------------------------------------------
# Command: list
# ------------------------------------------------------------------------------
cmd_list() {
    log_info "å¯ç”¨æŠ€èƒ½åˆ—è¡¨:"
    echo -e "${DIM}æ ¼å¼: â€¢ æŠ€èƒ½åç§° (åˆ†ç±»: ç›¸å¯¹è·¯å¾„)${NC}"
    echo ""
    
    local count=0
    local skill_info_list=()

    # ç¬¬ä¸€æ­¥ï¼šæ”¶é›†å¹¶å¤„ç†æ‰€æœ‰æŠ€èƒ½ä¿¡æ¯
    while IFS= read -r path; do
        local name=$(basename "$path")
        local rel_path="${path#$SKILLS_DIR/}"
        
        # å¤„ç† Folder Skill çš„ relative path
        local tag=""
        if [[ "$rel_path" == downloaded/* ]]; then
            tag="ä¸‹è½½"
        elif [[ "$rel_path" == system/* ]]; then
            tag="ç³»ç»Ÿ"
        elif [[ "$rel_path" == demo/* ]]; then
            tag="ç¤ºä¾‹"
        else
            tag="å†…ç½®"
        fi
        
        skill_info_list+=("$name|$tag|$rel_path")
        
    done < <(get_all_skills)
    
    # ç¬¬äºŒæ­¥ï¼šæ’åºå¹¶å±•ç¤º
    local IFS=$'\n'
    local sorted_list=($(printf '%s\n' "${skill_info_list[@]}" | sort))
    unset IFS

    for entry in "${sorted_list[@]}"; do
        IFS='|' read -r name tag subpath <<< "$entry"
        # æ ¼å¼åŒ–è¾“å‡ºï¼šâ€¢ åç§° (åˆ†ç±»: è·¯å¾„)
        echo -e "  ${GREEN}â€¢${NC} ${CYAN}$name${NC} ${DIM}($tag: $subpath)${NC}"
        ((count++))
    done
    
    echo ""
    log_info "å…± $count ä¸ªæŠ€èƒ½å¯ç”¨"
    echo -e "${DIM}æç¤º: ä½¿ç”¨ 'ash info <æŠ€èƒ½å>' æŸ¥çœ‹è¯¦ç»†æè¿°${NC}"
}

# ------------------------------------------------------------------------------
# Command: info
# ------------------------------------------------------------------------------
cmd_info() {
    local skill_name="$1"
    if [ -z "$skill_name" ]; then
        log_error "è¯·æä¾›æŠ€èƒ½åç§° (ä¾‹å¦‚: ash info pdf)"
        return 1
    fi

    local source_file; source_file=$(resolve_skill_path "$skill_name")
    local ret=$?
    
    if [ $ret -eq 0 ]; then
        # Handle Directory Skill: Use SKILL.md for info
        local content_file="$source_file"
        if [ -d "$source_file" ]; then
            content_file="$source_file/SKILL.md"
        fi

        local rel_path="${source_file#$SKILLS_DIR/}"
        echo -e "${CYAN}æŠ€èƒ½:${NC} $rel_path"
        
        # Extract description from content file
        local desc=$(extract_description "$content_file")
        echo -e "${GREEN}æè¿°:${NC} ${desc:-"(æ— æè¿°)"}"
        
        echo -e "${DIM}å†…å®¹é¢„è§ˆ:${NC}"
        if [ "$(head -n 1 "$content_file" 2>/dev/null)" == "---" ]; then
            sed '1,/---/d' "$content_file" | grep -v "^---" | head -n 10 | sed 's/^/  /'
        else
            head -n 10 "$content_file" | sed 's/^/  /'
        fi
    elif [ $ret -eq 1 ]; then
        log_error "æœªæ‰¾åˆ°åŒ¹é…çš„æŠ€èƒ½: $skill_name"
        return 1
    fi
}

# ------------------------------------------------------------------------------
# Command: search
# ------------------------------------------------------------------------------
cmd_search() {
    local keyword="$1"
    if [ -z "$keyword" ]; then
        log_error "è¯·æä¾›å…³é”®è¯è¿›è¡Œæœç´¢ (ä¾‹å¦‚: ash search react)"
        return 1
    fi

    log_info "æ­£åœ¨æœç´¢å…³é”®è¯: '$keyword' ..."
    echo ""

    local count=0
    while IFS= read -r item; do
        rel_path="${item#$SKILLS_DIR/}"
        
        # Resolve actual content file for description extraction
        local content_file="$item"
        if [ -d "$item" ]; then
            content_file="$item/SKILL.md"
        fi
        
        # è·å–æè¿°
        first_line=$(extract_description "$content_file")
        
        # åœ¨è·¯å¾„æˆ–æè¿°ä¸­æœç´¢ (ä¸åŒºåˆ†å¤§å°å†™)
        if echo "$rel_path $first_line" | grep -iq "$keyword"; then
            # Display: Use basename for cleaner output (like list) or rel_path?
            # User likely wants to see the skill name clearly.
            # list uses basename. search used rel_path.
            # Let's use basename for consistency, maybe showing parent dir in parens?
            local filename=$(basename "$item")
            
            echo -e "  ${GREEN}â€¢${NC} ${CYAN}$filename${NC} ${DIM}($rel_path)${NC}"
            if [ -n "$first_line" ]; then
                echo -e "    $first_line"
            fi
            ((count++))
        fi
    done < <(get_all_skills)

    if [ $count -eq 0 ]; then
        log_warn "æœªæ‰¾åˆ°åŒ¹é…çš„æŠ€èƒ½: $keyword"
    else
        echo ""
        log_info "æ‰¾åˆ° $count ä¸ªåŒ¹é…é¡¹"
    fi
}

# ------------------------------------------------------------------------------
# Command: status
# ------------------------------------------------------------------------------
cmd_status() {
    local full_mode=0
    local target_ide=""
    
    # è§£æå‚æ•°
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --full|-v|--list)
                full_mode=1
                shift
                ;;
            *)
                target_ide="$1"
                full_mode=1 # æŒ‡å®šç‰¹å®š IDE æ—¶ï¼Œè‡ªåŠ¨è¿›å…¥è¯¦ç»†æ¨¡å¼
                shift
                ;;
        esac
    done

    log_info "å·²å®‰è£…æŠ€èƒ½çŠ¶æ€:"
    if [ $full_mode -eq 0 ]; then
        echo -e "${DIM}æç¤º: ä½¿ç”¨ 'ash status --full' æˆ– 'ash status <ide_name>' æŸ¥çœ‹è¯¦æƒ…${NC}"
    fi
    echo ""
    
    # å®šä¹‰ IDE åç§° (ä¾›æ¨¡ç³ŠåŒ¹é…ä½¿ç”¨)
    local ide_names=("Antigravity" "Generic Agents" "Cursor" "TRAE" "Windsurf" "Copilot" "Claude" "Trae CN")
    local matched_any=0

    # Helper to check an IDE dir
    check_ide_status() {
        local ide_name="$1"
        local dir="$2"
        local found_in_ide=0
        
        # å¦‚æœæŒ‡å®šäº† target_ideï¼Œè¿›è¡Œæ¨¡ç³ŠåŒ¹é…è¿‡æ»¤
        if [ -n "$target_ide" ]; then
            local ide_lower=$(echo "$ide_name" | tr '[:upper:]' '[:lower:]')
            local target_lower=$(echo "$target_ide" | tr '[:upper:]' '[:lower:]')
            if [[ "$ide_lower" != *"$target_lower"* ]]; then
                return
            fi
            matched_any=1
        fi

        if [ -d "$dir" ]; then
            # Enable nullglob to handle empty dirs correctly
            shopt -s nullglob
            local links=("$dir"/*)
            shopt -u nullglob
            
            # ç»Ÿè®¡æœ‰æ•ˆé“¾æ¥
            local valid_links=()
            for link in "${links[@]}"; do
                if [ -L "$link" ]; then
                    valid_links+=("$link")
                    ((found_in_ide++))
                fi
            done
            
            # è¾“å‡ºæ ¼å¼
            if [ $full_mode -eq 1 ]; then
                 echo -e "  ${CYAN}${ide_name} ($dir):${NC}"
                 if [ ${#valid_links[@]} -eq 0 ]; then
                     echo -e "    ${YELLOW}(æ— )${NC}"
                 else
                     for link in "${valid_links[@]}"; do
                         local target=$(readlink "$link")
                         local name=$(basename "$link")
                         echo -e "    ${GREEN}â€¢${NC} $name -> $target"
                     done
                 fi
                 echo "" # è¯¦ç»†æ¨¡å¼å¢åŠ é—´è·
            else
                # ç´§å‡‘æ¨¡å¼
                if [ $found_in_ide -gt 0 ]; then
                    echo -e "  ${GREEN}âœ“${NC} ${CYAN}${ide_name}:${NC} å·²éƒ¨ç½² ${GREEN}$found_in_ide${NC} ä¸ªæŠ€èƒ½"
                else
                    echo -e "  ${DIM}â—‹ ${ide_name}:${NC} ${YELLOW}æœªå‘ç°å®‰è£…é¡¹${NC}"
                fi
            fi
        fi
    }

    check_ide_status "Antigravity" "$AGENT_SKILLS_DIR"
    check_ide_status "Generic Agents" "$HOME/.agents/skills"
    check_ide_status "Cursor" "$CURSOR_SKILLS_DIR"
    check_ide_status "TRAE" "$TRAE_SKILLS_DIR"
    check_ide_status "Windsurf" "$WINDSURF_SKILLS_DIR"
    check_ide_status "VS Code + Copilot" "$COPILOT_SKILLS_DIR"
    check_ide_status "Claude" "$CLAUDE_SKILLS_DIR"
    check_ide_status "Trae CN" "$TRAE_CN_SKILLS_DIR"
    
    if [ -n "$target_ide" ] && [ $matched_any -eq 0 ]; then
        log_error "æœªæ‰¾åˆ°åä¸º '$target_ide' çš„ IDEã€‚"
        echo -e "å¯ç”¨åç§°: ${DIM}${ide_names[*]}${NC}"
    fi

    if [ $full_mode -eq 0 ]; then echo ""; fi
}

# ------------------------------------------------------------------------------
# Command: clean
# ------------------------------------------------------------------------------
cmd_clean() {
    local target="$1"
    
    # å®šä¹‰ IDE åç§°åŠå…¶å¯¹åº”çš„è·¯å¾„ (éœ€ä¸ install_skill_file ä¿æŒä¸€è‡´)
    local ide_names=("Antigravity" "Generic Agents" "Cursor" "TRAE" "Windsurf" "Copilot" "Claude" "Trae CN")
    local dirs=("$AGENT_SKILLS_DIR" "$HOME/.agents/skills" "$CURSOR_SKILLS_DIR" "$TRAE_SKILLS_DIR" "$WINDSURF_SKILLS_DIR" "$COPILOT_SKILLS_DIR" "$CLAUDE_SKILLS_DIR" "$TRAE_CN_SKILLS_DIR")
    
    if [ -z "$target" ]; then
        echo -e "ç”¨æ³•: ash clean <ide_name> æˆ– ash clean --all"
        echo -e "å¯ç”¨ IDE: [${ide_names[*]}]"
        return 1
    fi

    # ç¡®è®¤æ“ä½œ
    echo -e "${YELLOW}è­¦å‘Š: æ­¤æ“ä½œå°†åˆ é™¤ç›®æ ‡ç›®å½•ä¸‹çš„æ‰€æœ‰æŠ€èƒ½é“¾æ¥ (ä¸ä¼šåˆ é™¤æºæ–‡ä»¶)ã€‚${NC}"
    read -p "ç¡®å®šè¦ç»§ç»­å—? [y/N] " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "å·²å–æ¶ˆã€‚"
        return 0
    fi

    local cleaned_any=0

    # Clean Logic
    clean_dir() {
        local dir="$1"
        local name="$2"
        
        if [ ! -d "$dir" ]; then
            # echo "Skipping $name: directory not found."
            return
        fi

        # Find count first
        local count=$(find "$dir" -maxdepth 1 -type l | wc -l | tr -d ' ')
        if [ "$count" -gt 0 ]; then
            # åªåˆ é™¤è½¯é“¾æ¥ï¼Œä¿ç•™ç”¨æˆ·å¯èƒ½æ‰‹åŠ¨æ”¾å…¥çš„å®ä½“æ–‡ä»¶ (å®‰å…¨èµ·è§)
            find "$dir" -maxdepth 1 -type l -delete
            log_success "å·²æ¸…ç©º $name æŠ€èƒ½ç›®å½• ($count ä¸ªé“¾æ¥å·²ç§»é™¤)ã€‚"
            ((cleaned_any++))
        else
            echo -e "${DIM}  $name: å·²ç»æ˜¯ç©ºçš„ã€‚${NC}"
        fi
    }

    if [ "$target" == "--all" ]; then
        for i in "${!ide_names[@]}"; do
            clean_dir "${dirs[$i]}" "${ide_names[$i]}"
        done
    else
        # Fuzzy match target name
        local found_target=0
        for i in "${!ide_names[@]}"; do
            # Case insensitive match (Bash 3.2 compatible)
            local ide_lower=$(echo "${ide_names[$i]}" | tr '[:upper:]' '[:lower:]')
            local target_lower=$(echo "${target}" | tr '[:upper:]' '[:lower:]')
            
            if [[ "$ide_lower" == "$target_lower" ]]; then
                clean_dir "${dirs[$i]}" "${ide_names[$i]}"
                found_target=1
                break
            fi
        done
        
        if [ $found_target -eq 0 ]; then
            log_error "æœªæ‰¾åˆ°åä¸º '$target' çš„ IDEã€‚"
            echo "å¯ç”¨åç§°: ${ide_names[*]}"
            return 1
        fi
    fi
    
    if [ $cleaned_any -eq 0 ]; then
        log_warn "æ²¡æœ‰æ‰§è¡Œä»»ä½•æ¸…ç†æ“ä½œ (ç›®å½•ä¸ºç©ºæˆ–ä¸å­˜åœ¨)ã€‚"
    fi
}


# ------------------------------------------------------------------------------
# Command: install
# ------------------------------------------------------------------------------
# è¾…åŠ©å‡½æ•°: å®‰è£…å•ä¸ªæŠ€èƒ½æ–‡ä»¶åˆ°æ‰€æœ‰æ£€æµ‹åˆ°çš„ IDE
# è¾…åŠ©å‡½æ•°: å®‰è£…å•ä¸ªæŠ€èƒ½(æ–‡ä»¶ æˆ– æ–‡ä»¶å¤¹)åˆ°æ‰€æœ‰æ£€æµ‹åˆ°çš„ IDE
install_skill_file() {
    local source_path="$1"
    local installed=0
    local filename=$(basename "$source_path")
    
    # æ£€æµ‹æ˜¯æ–‡ä»¶è¿˜æ˜¯æ–‡ä»¶å¤¹
    local is_dir=0
    if [ -d "$source_path" ]; then
        is_dir=1
    fi

    # å®šä¹‰ IDE ç›®å½•æ˜ å°„
    local targets=("$AGENT_SKILLS_DIR" "$CURSOR_SKILLS_DIR" "$TRAE_SKILLS_DIR" "$WINDSURF_SKILLS_DIR" "$COPILOT_SKILLS_DIR" "$CLAUDE_SKILLS_DIR" "$TRAE_CN_SKILLS_DIR")
    # å®šä¹‰å¯¹åº”æ˜¾ç¤ºçš„ IDE åç§°
    local ide_names=("Antigravity" "Cursor" "TRAE" "Windsurf" "Copilot" "Claude" "Trae CN")
    
    local installed_ides=()

    for i in "${!targets[@]}"; do
        local target_dir="${targets[$i]}"
        local ide_name="${ide_names[$i]}"
        
        if [ -d "$target_dir" ]; then
            local dest="$target_dir/$filename"
            
            # ä½¿ç”¨ ln -sfn å¼ºåˆ¶æ›´æ–°é“¾æ¥ (æ”¯æŒç›®å½•å’Œæ–‡ä»¶)
            ln -sfn "$source_path" "$dest"
            ((installed++))
            installed_ides+=("$ide_name")
        fi
    done

    if [ $installed -gt 0 ]; then
        local type_label="æ–‡ä»¶"
        [ $is_dir -eq 1 ] && type_label="ç›®å½•åŒ…"
        
        local ides_str=$(IFS=,; echo "${installed_ides[*]}")
        ides_str="${ides_str//,/ã€}"
        log_success "å·²å®‰è£… $type_label: $filename (${source_path#$SKILLS_DIR/})"
        echo -e "  ${DIM}â†³ åŒæ­¥è‡³ ${installed} ä¸ª IDE: [${CYAN}${ides_str}${DIM}]${NC}"
    fi
    return $installed
}

# ------------------------------------------------------------------------------
# Project Mode Helper: Bridge IDE Rules
# ç¡®ä¿å…¶ä»– IDE (Cursor, Windsurf, TRAE, Agent, etc.) èƒ½çœ‹åˆ° .claude/skills ä¸­çš„æŠ€èƒ½
# ------------------------------------------------------------------------------
bridge_ide_rules() {
    local project_root="$1"
    local skill_name="$2"     # e.g., "java.md"
    local source_file="$3"    # Absolute path to skill in .claude/skills/

    # å®šä¹‰ IDE é…ç½®æ˜ å°„
    # Logic: If project_root/.<ide> exists, create .<ide>/skills link
    local ide_dirs=("cursor" "windsurf" "trae" "trae-cn" "agent" "agents" "copilot")
    local ide_names=("Cursor" "Windsurf" "TRAE" "Trae CN" "Antigravity" "Generic Agents" "Copilot")

    for i in "${!ide_dirs[@]}"; do
        local dir_name=".${ide_dirs[$i]}"     # e.g., .cursor
        local pretty_name="${ide_names[$i]}"  # e.g., Cursor
        
        if [ -d "$project_root/$dir_name" ]; then
            local skills_dir="$project_root/$dir_name/skills"
            mkdir -p "$skills_dir"
            
            local target="$skills_dir/$skill_name"
            # Link to .claude source
            ln -sf "$source_file" "$target"
            log_info "  â†³ Bridge ($pretty_name): $dir_name/skills/$skill_name -> .claude"
        fi
    done
}

# ------------------------------------------------------------------------------
# Helper: Download from GitHub (Cloud Integration)
# ------------------------------------------------------------------------------
download_github_skill() {
    local repo_arg="$1"    # user/repo or user/repo/path
    local skill_option="$2" # Optional: specified via --skill flag
    
    # 1. Parse user/repo and subdir
    local user_repo=""
    local subdir=""
    
    # Regex check: user/repo...
    if [[ "$repo_arg" =~ ^([a-zA-Z0-9_\-]+)/([a-zA-Z0-9_\-]+)(/(.*))? ]]; then
        local user="${BASH_REMATCH[1]}"
        local repo="${BASH_REMATCH[2]}"
        user_repo="${user}/${repo}"
        subdir="${BASH_REMATCH[4]}" # Can be empty
    fi
    
    # --- Security Check: Third Party Repository ---
    # Whitelisted Orgs/Users
    local trusted_orgs="tiandee|anthropics|huggingface|vercel-labs|aws-samples|microsoft|google|openai"
    local repo_owner=$(echo "$user_repo" | cut -d'/' -f1)
    
    if [[ ! "$repo_owner" =~ ^($trusted_orgs)$ ]]; then
        log_warn "âš ï¸  å®‰å…¨è­¦å‘Š: æ‚¨æ­£åœ¨å®‰è£…æ¥è‡ªç¬¬ä¸‰æ–¹ç»„ç»‡ '$repo_owner' çš„æŠ€èƒ½ã€‚" >&2
        log_warn "   Source: https://github.com/${user_repo}" >&2
        echo -e "${YELLOW}   è¯·ç¡®ä¿æ‚¨ä¿¡ä»»è¯¥ä½œè€…ï¼Œå¹¶åœ¨å®‰è£…åæ£€æŸ¥ä»£ç ã€‚${NC}" >&2
        
        # Interactive confirmation
        if [ -t 0 ]; then
            read -p "â“ æ˜¯å¦ç»§ç»­å®‰è£…? [y/N] " confirm < /dev/tty
            if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
                log_error "å·²å–æ¶ˆå®‰è£…ã€‚" >&2
                return 1
            fi
        else
            # Non-interactive mode (e.g. CI), warn but proceed enabled? 
            # Or fail safe? Let's warn but proceed to verify 
            # Or require --force (future). For now, allow but log.
            log_warn "éäº¤äº’æ¨¡å¼: è‡ªåŠ¨ç»§ç»­å®‰è£…ã€‚" >&2
        fi
    fi

    # Override subdir if --skill flag is provided
    if [ -n "$skill_option" ]; then
        if [ -n "$subdir" ]; then
             log_warn "è·¯å¾„å†²çª: URLä¸­åŒ…å«äº†å­ç›®å½• '$subdir'ï¼Œä½†åŒæ—¶ä¹ŸæŒ‡å®šäº† --skill '$skill_option'ã€‚" >&2
             log_warn "å°†ä¼˜å…ˆä½¿ç”¨ --skill å‚æ•°ã€‚" >&2
        fi
        subdir="$skill_option"
    fi
    
    log_info "â˜ï¸  æ­£åœ¨ä» GitHub ä¸‹è½½: ${CYAN}${user_repo}${NC} ..." >&2
    if [ -n "$subdir" ]; then
        log_info "   Target Subdir: $subdir" >&2
    fi
    
    # 2. Clone to Temp Dir
    local tmp_dir="$ASH_HOME/tmp/$(date +%s)_$RANDOM"
    local clone_url="https://github.com/${user_repo}.git"
    
    mkdir -p "$tmp_dir"
    git clone --depth 1 "$clone_url" "$tmp_dir" > /dev/null 2>&1
    
    if [ $? -ne 0 ]; then
        log_error "GitHub å…‹éš†å¤±è´¥ã€‚è¯·æ£€æŸ¥ä»“åº“åœ°å€æˆ–ç½‘ç»œè¿æ¥ã€‚" >&2
        rm -rf "$tmp_dir"
        return 1
    fi
    
    # 3. Locate Target Skill
    local source_path="$tmp_dir"
    if [ -n "$subdir" ]; then
        source_path="$tmp_dir/$subdir"
        if [ ! -d "$source_path" ]; then
            log_error "æœªèƒ½åœ¨ä»“åº“ä¸­æ‰¾åˆ°æŒ‡å®šå­ç›®å½•: '$subdir'" >&2
            rm -rf "$tmp_dir"
            return 1
        fi
    fi
    
    # 4. Validation & Discovery
    local install_targets=()
    local is_valid_skill=0
    
    # Check if current path is a valid skill
    if [ -f "$source_path/SKILL.md" ] || [[ "$subdir" == *.md ]] || [ -f "$source_path/${repo}.md" ]; then
        is_valid_skill=1
        install_targets+=("$source_path")
    fi
    
    # --- Interactive Discovery Logic ---
    if [ $is_valid_skill -eq 0 ]; then
        log_info "æ£€æµ‹åˆ°å½“å‰è·¯å¾„ä¸ºæŠ€èƒ½åˆé›†å®¹å™¨ (Monorepo)ï¼Œæ­£åœ¨æ‰«æå†…éƒ¨æŠ€èƒ½..." >&2
        
        # Find all SKILL.md files (max depth 4)
        local candidates=()
        while IFS= read -r file; do
            candidates+=("$file")
        done < <(find "$source_path" -maxdepth 4 -name "SKILL.md" | sort)
        
        local count=${#candidates[@]}
        
        if [ $count -eq 0 ]; then
            log_error "æ‰«æå®Œæˆï¼Œæœªåœ¨ä»“åº“ä¸­å‘ç°ä»»ä½•æœ‰æ•ˆæŠ€èƒ½ã€‚" >&2
            rm -rf "$tmp_dir"
            return 1
        elif [ $count -eq 1 ]; then
            # Auto-select the only one found
            local skill_file="${candidates[0]}"
            local target_path=$(dirname "$skill_file")
            log_success "å‘ç°å”¯ä¸€æŠ€èƒ½: ${CYAN}$(basename "$target_path")${NC}" >&2
            install_targets+=("$target_path")
        else
            # Interactive Selection
            echo -e "\n${GREEN}å‘ç° $count ä¸ªå¯ç”¨æŠ€èƒ½:${NC}" >&2
            local i=1
            for file in "${candidates[@]}"; do
                local dir=$(dirname "$file")
                local rel_path="${dir#$tmp_dir/}"
                echo -e "  ${CYAN}[$i]${NC} $rel_path" >&2
                ((i++))
            done
            
            echo "" >&2
            local selection
            # Read from /dev/tty
            if [ -t 0 ]; then
                 read -p "è¯·é€‰æ‹©æŠ€èƒ½ç¼–å· (æ”¯æŒå¤šé€‰å¦‚ '1,3' æˆ– 'all' å…¨éƒ¨): " selection < /dev/tty
            else
                 log_error "æ— æ³•è¿›è¡Œäº¤äº’å¼é€‰æ‹© (é TTY ç¯å¢ƒ)ã€‚" >&2
                 rm -rf "$tmp_dir"
                 return 1
            fi
            
            # Parse Selection
            local selected_indices=()
            local selection_lower=$(echo "$selection" | tr '[:upper:]' '[:lower:]')
            if [[ "$selection_lower" == "all" ]]; then
                selected_indices=($(seq 1 $count))
                log_success "å·²é€‰æ‹©: å…¨éƒ¨ $count ä¸ªæŠ€èƒ½" >&2
            else
                # Split by comma
                IFS=',' read -ra ADDR <<< "$selection"
                for idx in "${ADDR[@]}"; do
                    # Trim spaces
                    idx=$(echo "$idx" | xargs) 
                    if [[ ! "$idx" =~ ^[0-9]+$ ]] || [ "$idx" -lt 1 ] || [ "$idx" -gt "$count" ]; then
                        log_warn "å¿½ç•¥æ— æ•ˆç¼–å·: $idx" >&2
                    else
                        selected_indices+=("$idx")
                    fi
                done
            fi
            
            if [ ${#selected_indices[@]} -eq 0 ]; then
                log_error "æœªé€‰æ‹©ä»»ä½•æœ‰æ•ˆæŠ€èƒ½ã€‚" >&2
                rm -rf "$tmp_dir"
                return 1
            fi
            
            for idx in "${selected_indices[@]}"; do
                local s_file="${candidates[$((idx-1))]}"
                local target_path=$(dirname "$s_file")
                install_targets+=("$target_path")
                local s_name=$(basename "$target_path")
                log_success "å·²æ·»åŠ : ${CYAN}$s_name${NC}" >&2
            done
        fi
    fi
    
    # 5. Move to ~/.ash/skills/downloaded/
    local download_root="$SKILLS_DIR/downloaded"
    mkdir -p "$download_root"
    
    for src in "${install_targets[@]}"; do
        # Determine Skill Name
        local skill_name=""
        if [ -f "$src/SKILL.md" ]; then
             skill_name=$(basename "$src")
        elif [[ "$src" == *.md ]]; then
             skill_name=$(basename "$src" .md)
        elif [ -f "$src/${repo}.md" ]; then
             skill_name="$repo"
             # If src is file
             if [ -f "$src" ]; then 
                 skill_name=$(basename "$src" .md)
             fi
        fi
        
        # Determine target path
        if [ -f "$src" ]; then
             local target_file="$download_root/${skill_name}.md"
             mv "$src" "$target_file"
             echo "$target_file"
        else
             local target_dir="$download_root/$skill_name"
             # Conflict Handling: Overwrite/Merge (Silent Overwrite for batch ops)
             if [ -d "$target_dir" ]; then
                 rm -rf "$target_dir"
             fi
             mv "$src" "$target_dir"
             echo "$target_dir"
        fi
    done
    
    rm -rf "$tmp_dir"
    return 0
}

# ------------------------------------------------------------------------------
# Project Mode Core: Install to Project
# ------------------------------------------------------------------------------
install_to_project() {
    local skill_path="$1"
    local project_path="$2"
    
    # 1. ç¡®å®šé¡¹ç›®æ ¹ç›®å½•
    if [ -z "$project_path" ]; then
        project_path=$(pwd)
    fi
    # Resolve absolute path for project_path
    project_path=$(cd "$project_path" && pwd)

    local filename=$(basename "$skill_path")
    
    # 2. å»ºç«‹æ ‡å‡†å­˜å‚¨: .claude/skills (Single Source of Truth)
    local claude_skills="$project_path/.claude/skills"
    mkdir -p "$claude_skills"
    
    local target="$claude_skills/$filename"
    
    # 3. å®‰è£…åˆ° .claude/skills
    ln -sfn "$skill_path" "$target"
    log_success "å·²å®‰è£…åˆ°é¡¹ç›®: ${CYAN}.claude/skills/$filename${NC}"
    
    # 4. å»ºç«‹ IDE æ¡¥æ¥
    bridge_ide_rules "$project_path" "$filename" "$target"
}

# ------------------------------------------------------------------------------
# Helper: Check and Auto-Init (Lazy Initialization)
# ------------------------------------------------------------------------------
check_and_auto_init() {
    local dirs=("$AGENT_SKILLS_DIR" "$CURSOR_SKILLS_DIR" "$TRAE_SKILLS_DIR" "$WINDSURF_SKILLS_DIR" "$COPILOT_SKILLS_DIR" "$CLAUDE_SKILLS_DIR" "$TRAE_CN_SKILLS_DIR")
    local initialized=0
    
    for dir in "${dirs[@]}"; do
        if [ -d "$dir" ]; then
            initialized=1
            break
        fi
    done

    if [ $initialized -eq 0 ]; then
        echo -e "${YELLOW}[æç¤º] æ£€æµ‹åˆ°å°šæœªåˆå§‹åŒ–ç¯å¢ƒï¼Œæ­£åœ¨è‡ªåŠ¨æ‰§è¡Œåˆå§‹åŒ–...${NC}"
        cmd_init
        echo ""
    fi
}

# ------------------------------------------------------------------------------
# Command: install
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Helper: Execute installation for a single skill (Global or Project)
# ------------------------------------------------------------------------------
execute_skill_installation() {
    local skill_path="$1"
    local mode="$2"
    local project_path="$3"

    if [ "$mode" == "project" ]; then
        install_to_project "$skill_path" "$project_path"
    else
        # Global Install (Original Logic)
        local filename=$(basename "$skill_path")
        local rel_path="${skill_path#$SKILLS_DIR/}"
        
        log_success "å·²å®‰è£… ${CYAN}$filename${NC} ($rel_path)"
        
        local count=0
        local updated_ides=() # Use array to store list
        
        local ides=("Antigravity" "Generic Agents" "Cursor" "TRAE" "Windsurf" "Copilot" "Claude" "Trae CN")
        local dirs=("$AGENT_SKILLS_DIR" "$HOME/.agents/skills" "$CURSOR_SKILLS_DIR" "$TRAE_SKILLS_DIR" "$WINDSURF_SKILLS_DIR" "$COPILOT_SKILLS_DIR" "$CLAUDE_SKILLS_DIR" "$TRAE_CN_SKILLS_DIR")
        
        for i in "${!ides[@]}"; do
            local ide_name="${ides[$i]}"
            local dir="${dirs[$i]}"
            
            if [ -d "$dir" ]; then
                # Link creation
                ln -sfn "$skill_path" "$dir/$filename"
                ((count++))
                updated_ides+=("$ide_name")
            fi
        done
        
        if [ $count -gt 0 ]; then
             local ide_list_str=$(IFS=, ; echo "${updated_ides[*]}")
             ide_list_str=$(echo "$ide_list_str" | sed 's/,/, /g')
             echo -e "  â†³ åŒæ­¥è‡³ $count ä¸ª IDE: [${GREEN}$ide_list_str${NC}]"
        else
            log_warn "æœªæ£€æµ‹åˆ°ä»»ä½•å·²åˆå§‹åŒ–çš„ IDE æŠ€èƒ½ç›®å½•ã€‚"
        fi
    fi
}
cmd_install() {
    local skill_name="$1"
    local mode="global"
    local project_path=""
    
    # Parse Arguments manually since we have optional flags
    shift # Remove first arg (skill_name)
    local skill_option=""
    
    while [[ "$#" -gt 0 ]]; do
        case $1 in
            -p|--project)
                mode="project"
                if [[ -n "$2" && "$2" != -* ]]; then
                    project_path="$2"
                    shift
                fi
                ;;
            --skill)
                 if [[ -n "$2" ]]; then
                    skill_option="$2"
                    shift
                 fi
                 ;;
            *)
                ;;
        esac
        shift
    done

    if [ -z "$skill_name" ]; then
        log_error "è¯·æŒ‡å®šè¦å®‰è£…çš„æŠ€èƒ½åç§°ã€‚"
        echo "ç”¨æ³•: ash add <name> [-p [path]]"
        return 1
    fi

    # --- Special Case: --all (Install/Sync all local skills) ---
    if [ "$skill_name" == "--all" ]; then
        log_info "æ­£åœ¨æ‰¹é‡å®‰è£…æ‰€æœ‰æœ¬åœ°æŠ€èƒ½..."
        
        # Auto-Init Check (Global Mode Only)
        if [ "$mode" == "global" ]; then
            check_and_auto_init
        fi
        
        local total=0
        while IFS= read -r skill_path; do
            if [ -z "$skill_path" ]; then continue; fi
            execute_skill_installation "$skill_path" "$mode" "$project_path"
            ((total++))
        done < <(get_all_skills)
        
        log_success "æ‰¹é‡å®‰è£…å®Œæˆï¼å…±å¤„ç† $total ä¸ªæŠ€èƒ½ã€‚"
        return 0
    fi

    local status=0
    # Store output in a variable to handle multiple lines
    local install_output=""
    
    # --- GitHub / Cloud Installer Logic ---
    # Regex: Detect 'user/repo' pattern (simple check: contains / and not starting with / or .)
    if [[ "$skill_name" =~ ^[a-zA-Z0-9_\-]+/[a-zA-Z0-9_\-]+ ]]; then
        install_output=$(download_github_skill "$skill_name" "$skill_option")
        status=$?
        
        if [ $status -ne 0 ]; then
            return 1
        fi
        
        # Parse output line by line (support multi-select installation)
        while IFS= read -r skill_path; do
            if [ -z "$skill_path" ]; then continue; fi
            
            # Reset skill_name to the basename of downloaded skill for linking
            local current_skill_name=$(basename "$skill_path")
            if [[ "$current_skill_name" == *.md ]]; then
                 current_skill_name="${current_skill_name%.md}"
            fi
            
            log_success "ä¸‹è½½æˆåŠŸ: ${CYAN}$current_skill_name${NC}"
            
            # --- Auto-Init Check (Global Mode Only) ---
            if [ "$mode" == "global" ]; then
                check_and_auto_init
            fi
            
            # --- Execution ---
            execute_skill_installation "$skill_path" "$mode" "$project_path"
             
        done <<< "$install_output"
        return 0
        
    else 
        # --- Local Resolution Logic (Single Skill) ---
        local skill_path=""
        skill_path=$(resolve_skill_path "$skill_name")
        status=$?
    
        if [ $status -ne 0 ]; then
            if [ $status -eq 1 ]; then
                log_error "æœªæ‰¾åˆ°æŠ€èƒ½: '$skill_name'"
                # Suggestion Logic
                local best_match=$(find "$SKILLS_DIR" -name "*.md" | xargs basename | grep -i "$skill_name" | head -n 1)
                 if [ -n "$best_match" ]; then
                    echo -e "ğŸ’¡ æ‚¨æ˜¯ä¸æ˜¯æƒ³å®‰è£…: ${CYAN}${best_match%.md}${NC} ?"
                fi
            fi
            return 1
        fi
        

    fi

    # --- Auto-Init Check (Global Mode Only) ---
    if [ "$mode" == "global" ]; then
        check_and_auto_init
    fi
    
    # --- Execution ---
    execute_skill_installation "$skill_path" "$mode" "$project_path"
}

# ------------------------------------------------------------------------------
# Helper: Remove all skill links from all IDEs
# ------------------------------------------------------------------------------
remove_all_links() {
    log_info "æ­£åœ¨ä»æ‰€æœ‰ IDE å¸è½½æ‰€æœ‰æŠ€èƒ½..."
    local total_count=0
    
    # å®šä¹‰ IDE åç§°åŠå…¶å¯¹åº”çš„è·¯å¾„
    local ides=("Antigravity" "Generic Agents" "Cursor" "TRAE" "Windsurf" "Copilot" "Claude" "Trae CN")
    local dirs=("$AGENT_SKILLS_DIR" "$HOME/.agents/skills" "$CURSOR_SKILLS_DIR" "$TRAE_SKILLS_DIR" "$WINDSURF_SKILLS_DIR" "$COPILOT_SKILLS_DIR" "$CLAUDE_SKILLS_DIR" "$TRAE_CN_SKILLS_DIR")
    
    for i in "${!ides[@]}"; do
        local ide_name="${ides[$i]}"
        local dir="${dirs[$i]}"
        local ide_count=0
        local removed_skills=()
        
        if [ -d "$dir" ]; then
            # è®°å½•è¯¥ IDE ä¸‹ç§»é™¤çš„æ‰€æœ‰æŠ€èƒ½
            for link in "$dir"/*; do
                if [ -L "$link" ]; then
                    local filename=$(basename "$link")
                    rm "$link"
                    removed_skills+=("$filename")
                    ((ide_count++))
                    ((total_count++))
                fi
            done
            
            # è¾“å‡ºè¯¥ IDE çš„ç»“æœ
            if [ $ide_count -gt 0 ]; then
                # å°†æ•°ç»„è½¬æ¢ä¸ºé€—å·åˆ†éš”çš„å­—ç¬¦ä¸²
                local skills_list=$(IFS=,; echo "${removed_skills[*]}")
                echo -e "  ${CYAN}$ide_name:${NC} å·²ç§»é™¤ ${GREEN}$ide_count${NC} ä¸ªæŠ€èƒ½ [${DIM}${skills_list//,/ã€}${NC}]"
            fi
        fi
    done
    
    echo ""
    if [ $total_count -gt 0 ]; then
        log_success "å…¨é‡å¸è½½å®Œæˆï¼Œå…±ä»æ‰€æœ‰ IDE ä¸­ç§»é™¤äº† $total_count ä¸ªé“¾æ¥ã€‚"
    else
        log_warn "æœªå‘ç°ä»»ä½•å·²å®‰è£…çš„æŠ€èƒ½é“¾æ¥ã€‚"
    fi
}

# ------------------------------------------------------------------------------
# Command: uninstall
# ------------------------------------------------------------------------------
cmd_uninstall() {
    local skill_name="$1"
    
    if [ "$skill_name" == "--all" ]; then
        remove_all_links
        return 0
    fi
    
    if [ -z "$skill_name" ]; then
        log_error "è¯·æŒ‡å®šè¦å¸è½½çš„æŠ€èƒ½åç§° (ä¾‹å¦‚: expert æˆ– expert.mdï¼Œæˆ–ä½¿ç”¨ --all)"
        return 1
    fi
    
    local removed=0
    
    # å®šä¹‰ IDE åç§°åŠå…¶å¯¹åº”çš„è·¯å¾„
    local ides=("Antigravity" "Generic Agents" "Cursor" "TRAE" "Windsurf" "Copilot" "Claude" "Trae CN")
    local dirs=("$AGENT_SKILLS_DIR" "$HOME/.agents/skills" "$CURSOR_SKILLS_DIR" "$TRAE_SKILLS_DIR" "$WINDSURF_SKILLS_DIR" "$COPILOT_SKILLS_DIR" "$CLAUDE_SKILLS_DIR" "$TRAE_CN_SKILLS_DIR")
    
    for i in "${!ides[@]}"; do
        local ide_name="${ides[$i]}"
        local dir="${dirs[$i]}"
        
        if [ -d "$dir" ]; then
            # 1. å°è¯•ç§»é™¤å®Œå…¨åŒ¹é…çš„åç§° (ç”¨äºæ–‡ä»¶å¤¹å‹æŠ€èƒ½ æˆ– æ˜¾å¼å¸¦åç¼€çš„æ–‡ä»¶)
            local link="$dir/$skill_name"
            if [ -L "$link" ]; then
                rm "$link"
                log_success "å·²ä» $ide_name ç§»é™¤: $skill_name"
                ((removed++))
            fi
            
            # 2. å¦‚æœè¾“å…¥ä¸å¸¦ .mdï¼Œå°è¯•ç§»é™¤å¸¦ .md åç¼€çš„æ–‡ä»¶
            if [[ "$skill_name" != *.md ]]; then
                local link_md="$dir/${skill_name}.md"
                if [ -L "$link_md" ]; then
                    rm "$link_md"
                    log_success "å·²ä» $ide_name ç§»é™¤: ${skill_name}.md"
                    ((removed++))
                fi
            fi
        fi
    done
    
    if [ $removed -eq 0 ]; then
        log_warn "æœªæ‰¾åˆ°å·²å®‰è£…çš„æŠ€èƒ½: $skill_name"
    fi
}


# ------------------------------------------------------------------------------
# Main Dispatch
# ------------------------------------------------------------------------------
case "$1" in
    init)
        cmd_init
        ;;
    list)
        cmd_list
        ;;
    info)
        shift
        cmd_info "$@"
        ;;
    search)
        shift
        cmd_search "$@"
        ;;
    status)
        shift
        cmd_status "$@"
        ;;
    "install"|"add")
        shift
        cmd_install "$@"
        ;;
    uninstall)
        shift
        cmd_uninstall "$@"
        ;;
    clean)
        shift
        cmd_clean "$@"
        ;;
    sync)
        cmd_sync
        ;;
    -v|--version)
        show_version
        ;;
    -h|--help)
        show_help
        ;;
    "")
        show_help
        ;;
    *)
        command="$1"
        log_error "æœªçŸ¥å‘½ä»¤: '$command'"
        
        # æ™ºèƒ½å»ºè®®é€»è¾‘
        case "$command" in
            intall|insall|instal)
                echo -e "ğŸ’¡ æ‚¨æ˜¯ä¸æ˜¯æƒ³è¾“å…¥: ${CYAN}ash add${NC} ?"
                ;;
            unintall|uninstal)
                echo -e "ğŸ’¡ æ‚¨æ˜¯ä¸æ˜¯æƒ³è¾“å…¥: ${CYAN}ash uninstall${NC} ?"
                ;;
            ls|lst)
                echo -e "ğŸ’¡ æ‚¨æ˜¯ä¸æ˜¯æƒ³è¾“å…¥: ${CYAN}ash list${NC} ?"
                ;;
            serch|find)
                echo -e "ğŸ’¡ æ‚¨æ˜¯ä¸æ˜¯æƒ³è¾“å…¥: ${CYAN}ash search${NC} ?"
                ;;
            stat|st)
                echo -e "ğŸ’¡ æ‚¨æ˜¯ä¸æ˜¯æƒ³è¾“å…¥: ${CYAN}ash status${NC} ?"
                ;;
            *)
                echo -e "è¯¦æƒ…è¯·è¿è¡Œ: ${DIM}ash --help${NC}"
                ;;
        esac
        exit 1
        ;;
esac
